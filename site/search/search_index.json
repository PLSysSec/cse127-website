{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"This course focuses on computer security, covering a wide range of topics on both the \"defensive\" and \"offensive\" side of this field. Among these will be systems security and exploitation (buffer overflows, race conditions, SQL injection, etc), access control and authentication, covert channels, network security, language-based security, denial-of-service, privacy and anonymity. The goal of the course is to provide an appreciation of how to think adversarially with respect to computer systems as well as an appreciation of how to reason about attacks and defenses. To complete the projects in this course, you will need the ability to develop software programs using the C language, and some understanding of x86 assembly, JavaScript, PHP and SQL. We will not reach these in class and you will be expected to learn them on your own. If you don't know C, K&R's The C Programming Language is a great go to, but the Hacking book is probably enough and covers some x86 assembly too. Class details \u00b6 Lectures: Mondays and Wednesdays, 6:30-7:50PM in SOLIS 104 Section: Tuesdays, 8:00-8:50PM in CENTER 105 Staff email: ucsd-cse127-winter19@googlegroups.com Piazza: https://piazza.com/ucsd/winter2019/cse127 Textbook \u00b6 We will occasionally be assinging readings from Ross Anderson's Security Engineering and various other online resources and papers. We may also assign optional reading from Jon Erickson's Hacking: The Art of Exploitation . Course Staff \u00b6 Instructor: Deian Stefan TAs: Nadah Feteih, Jonathan Luck, Kaiser Pister, and Michael Smith . Grading \u00b6 30% Homeworks assignments 30% Midterm exam 40% Final exam +5% Participation in class and online Homework and programming labs \u00b6 We will have homework assignments that are meant to both reinforce your knowledge of the concepts covered in lecture and get you to think about security in more depth, beyond what is covered lecture. You are expected to work on the assignments by yourself. You may discuss the assignments with students from the course, in general, but not any specific solution. There are no late days, but you will receive an additional 10% if you turn in your assignment by the early date. If you consult anything (books, academic papers, internet resources, people not in your group) when working on the assignments, note this in your submission. We encourage outside learning but expect you to not seek out specific details about a solution -- anything submitted should be considered your own work. Similarly, you are expected to not publish or otherwise share your solutions at any point (even after the class is over). If you are unsure about what is allowed, please ask the course staff. Exams \u00b6 The midterm exam will be held in class on February 13th. The midterm is closed-book , but you may use a double-sided cheat sheet (letter-size). The final exam will be held on March 20th in TBA from 7:00PM-9:59PM. You must take the exam at this time and location. The final is closed-book , but you may use 2 double-sided cheat sheets (letter-size). The exams will make up 70% of your grade. Since the final is cumulative your midterm grade will be calculated as: midterm > 0 ? max(final, midterm) : 0 This means that (1) you basically get a second chance if you don't so well on the midterm and (2) you must show up to both the midterm and the final. If you need to miss either exam because of a documented medical emergency, contact the instructor immediately. Participation/pre-lecture readings \u00b6 Before each class there will be some assigned reading. You are expected to do the reading and have at least a vague understanding of the concepts that will be discussed in class. This will allow us to spend the lecture time to solidify your understanding. Asking and answering questions in class, on Piazza, or during office hours counts towards your class participation. Acknowledgements \u00b6 The course structure and many of the ideas are influenced or directly from Stefan Savage, Kirill Levchenko, and Hovav Shacham. Academic integrity and student conduct \u00b6 By taking this course, you implicitly agree to abide by the UCSD policies on Integrity of Scholarship and Student Conduct . University rules on integrity of scholarship and code of conduct are taken seriously and will be enforced.","title":"About"},{"location":"#class-details","text":"Lectures: Mondays and Wednesdays, 6:30-7:50PM in SOLIS 104 Section: Tuesdays, 8:00-8:50PM in CENTER 105 Staff email: ucsd-cse127-winter19@googlegroups.com Piazza: https://piazza.com/ucsd/winter2019/cse127","title":"Class details"},{"location":"#textbook","text":"We will occasionally be assinging readings from Ross Anderson's Security Engineering and various other online resources and papers. We may also assign optional reading from Jon Erickson's Hacking: The Art of Exploitation .","title":"Textbook"},{"location":"#course-staff","text":"Instructor: Deian Stefan TAs: Nadah Feteih, Jonathan Luck, Kaiser Pister, and Michael Smith .","title":"Course Staff"},{"location":"#grading","text":"30% Homeworks assignments 30% Midterm exam 40% Final exam +5% Participation in class and online","title":"Grading"},{"location":"#homework-and-programming-labs","text":"We will have homework assignments that are meant to both reinforce your knowledge of the concepts covered in lecture and get you to think about security in more depth, beyond what is covered lecture. You are expected to work on the assignments by yourself. You may discuss the assignments with students from the course, in general, but not any specific solution. There are no late days, but you will receive an additional 10% if you turn in your assignment by the early date. If you consult anything (books, academic papers, internet resources, people not in your group) when working on the assignments, note this in your submission. We encourage outside learning but expect you to not seek out specific details about a solution -- anything submitted should be considered your own work. Similarly, you are expected to not publish or otherwise share your solutions at any point (even after the class is over). If you are unsure about what is allowed, please ask the course staff.","title":"Homework and programming labs"},{"location":"#exams","text":"The midterm exam will be held in class on February 13th. The midterm is closed-book , but you may use a double-sided cheat sheet (letter-size). The final exam will be held on March 20th in TBA from 7:00PM-9:59PM. You must take the exam at this time and location. The final is closed-book , but you may use 2 double-sided cheat sheets (letter-size). The exams will make up 70% of your grade. Since the final is cumulative your midterm grade will be calculated as: midterm > 0 ? max(final, midterm) : 0 This means that (1) you basically get a second chance if you don't so well on the midterm and (2) you must show up to both the midterm and the final. If you need to miss either exam because of a documented medical emergency, contact the instructor immediately.","title":"Exams"},{"location":"#participationpre-lecture-readings","text":"Before each class there will be some assigned reading. You are expected to do the reading and have at least a vague understanding of the concepts that will be discussed in class. This will allow us to spend the lecture time to solidify your understanding. Asking and answering questions in class, on Piazza, or during office hours counts towards your class participation.","title":"Participation/pre-lecture readings"},{"location":"#acknowledgements","text":"The course structure and many of the ideas are influenced or directly from Stefan Savage, Kirill Levchenko, and Hovav Shacham.","title":"Acknowledgements"},{"location":"#academic-integrity-and-student-conduct","text":"By taking this course, you implicitly agree to abide by the UCSD policies on Integrity of Scholarship and Student Conduct . University rules on integrity of scholarship and code of conduct are taken seriously and will be enforced.","title":"Academic integrity and student conduct"},{"location":"contact/","text":"For general information and questions, please post to the class Piazza . It's very likely that other students will have the same question. We will post announcements on Piazza, so please make sure to sign up. For urgent or personal matters, please post a private question or contact the course staff by email. Course staff email address: ucsd-cse127-winter19@googlegroups.com Instructor \u00b6 Name: Deian Stefan Email: deian+cse127@cs.ucsd.edu Address: CSE 3126 Office Hours: Monday 1-2PM or by appointment, CSE 3126 Teaching Assistants \u00b6 Name: Nadah Feteih Office Hours: Tuesday 3:30PM-4:30PM in CSE B240a Name: Kaiser Pister Office hours: Wednesday 11AM-12PM at the whiteboard outside CSE 3140 Name: Michael Smith Office hours: Thursday 6:30PM-7:30PM at the whiteboard outside CSE 3140","title":"Contact information"},{"location":"contact/#instructor","text":"Name: Deian Stefan Email: deian+cse127@cs.ucsd.edu Address: CSE 3126 Office Hours: Monday 1-2PM or by appointment, CSE 3126","title":"Instructor"},{"location":"contact/#teaching-assistants","text":"Name: Nadah Feteih Office Hours: Tuesday 3:30PM-4:30PM in CSE B240a Name: Kaiser Pister Office hours: Wednesday 11AM-12PM at the whiteboard outside CSE 3140 Name: Michael Smith Office hours: Thursday 6:30PM-7:30PM at the whiteboard outside CSE 3140","title":"Teaching Assistants"},{"location":"syllabus/","text":"Date Topics Jan 7 Overview and introduction Optional reading: Chapter 0x200 of Hacking Jan 9 Security foundations Reading: Thompson's Reflections on Trusting Trust , Ch 1 , and Ch 4.1-4.2 Jan 14 Security foundations (in-class discussion) Kirill's slides Jan 16 Stack buffer-overflows Reading: Aleph One's Smashing the Stack for Fun and Profit Optional reading: 0x300-0x320 from Hacking. 0x200-0x270 if you don't have a strong C background. Jan 21 MLK - no class Jan 23 ASLR and W^X Reading: Eternal War in Memory by Szekeres et al., ASLR , and NOEXEC Jan 28 Return-oriented programming Reading: On the Effectiveness of Address-Space Randomization by Shacham et al., The Geometry of Innocent Flesh on the Bone: Return-into-libc without Function Calls (on the x86) by Shacham, and Hacking BLind by Bittau et al. Jan 30 Control flow integrity Reading: Control-Flow Integrity by Abadi et al., Control-Flow Bending: On the Effectiveness of Control-Flow Integrity by Carlini et al. and Control-Flow Integrity: Precision, Security, and Performance by Burow et al. Feb 4 Memory safety Reading: SoftBound: Highly Compatible and CompleteSpatial Memory Safety for C by Nagarakatte et al., Oscar: A Practical Page-Permissions-Based Scheme for Thwarting Dangling Pointers by Dang et al., and Bringing Memory Safety to WebAssembly by Disselkoen et al. Feb 6 Least privilege and privilege separation Reading: Operating Systems Security by Jaeger Feb 11 Isolation and short review Reading: Efficient Software-Based Fault Isolation by Wahbe et al. Feb 12 Midterm review Feb 13 Midterm exam (in-class) Feb 18 President's day - no class Feb 20 Page tables, VMs, and side channels Reading: Remote Timing Attacks are Practical by Brumley and Boneh Feb 25 Web security model and CSRF Reading: CSRF and Same Origin Policy Lecture code: CSRF simple app Feb 27 CSRF, XSS, SQLi Reading: XSS Game and SQL Injection Mar 4 Modern client-side security mechanisms Reading CSP , iframe sandbox , CORS , SRI , Mixed content , Busting Frame Busting:a Study of Clickjacking Vulnerabilities on Popular Site by Rydstedt et al. Mar 6 Intro to cryptography Reading: Security Engineering, Ch 5 , BREACH Mar 11 PKI, HTTPS, and CT Reading: Ten Risks of PKI by Ellison and Schneier, Towards Short-Lived Certificates by Topalovic et al., The New Illustrated TLS Connection , CT log searches , and CRLite: a Scalable System for Pushing all TLS Revocations to All Browsers by Larisch et al. Mar 13 Network security Reading: A Look Back at Security Problems in the TCP/IP Protocol Suite by Bellovin, An Illustrated Guide to the Kaminsky DNS Vulnerability by Friedl Mar 20 Final exam 7-10PM","title":"Syllabus"},{"location":"notes/lecture13/","text":"CSRF \u00b6 The same origin policy does not prevent cross-origin requests from being sent. It only prevents you from processing/inspecting the response. So? If you're logged into bank.ch and bank.ch doesn't \"properly\" handle requests -- i.e., it only checks the cookie to make sure you're authenticated -- then evil.com can send a request to, say, transfer funds out of your account. For example, the attacker can send a POST request via an HTML <form> element or just use the XHR/fetch JavaScript APIs. In general POST requests are considered the most general because they inherently modify state server-side. But, some web sites take query parameters from a GET request and modify state server-side too (e.g., you can do forms this way just as well), and an attacker can just as easily abuse this. Defenses \u00b6 Goal: server wants to make sure request is coming from same origin (or from an origin it trusts). CSRF tokens \u00b6 The most common way to deal with this is to create random token and include them in your forms as hidden values. Server-side, you can now just check that the request body (after praising) contains the right token. What happens if you forget to add token to form field? What happens if you forget to check tokens server-side? What do you do about GET requests? What's the trade-off? (How does this play with CDNs?) Referrer and origin headers \u00b6 Browser sends referrer header to server to indicate what the URL of the page that made the request is. Full URL is not great for privacy and many organizations filter referrer headers. Origin header just includes the origin of the page. Mostly just for POST requests. Largely designed to deal with CSRF. Support for origin header not done in all browsers. What's the trade-off when comparsed to tokens? XSS \u00b6 XSS is a way of injecting scripts that execute client-side unintentionally. Stored XXS \u00b6 A classical example of an XSS attack is a forum that renders HTML-sylized user comments. If the forum is not \"properly\" implemented -- i.e., if the server does not properly filter data -- a malcious user can upload a comment that contains a <script> element. Any other user that then views the page that contains the comment will then be pwned: the malicious script will run in the context of the victim web app. So, for example, the script can steal the user's cookie, leak data, etc. This is called a stored XSS attack because the script is stored in the form database and happily shipped to the client (browser) by the forum web app. Reflected XSS \u00b6 This is not the only vector though. For example, this link https://duckduckgo.com/?q=xss when you click on it will not only navigate you to http://duckduckgo.com but also populate the search bar. If they didn't implement sanitization properly an attacker can craft a link that includes code. For example, they can set the query string to \"><script>alert('pwn')</script to close the <input value=\"...> field and add a script element. (Duckduckgo actually handles this so this won't work if you try it.) This XSS attack requires the victim to click on a link (or type in a URL, submit GET form, etc.). This is called a reflected XSS attacks , it takes advantage of the fact that the web site reflects what's in the URL on the page. Defenses \u00b6 Sanitization \u00b6 The typical approach is to consider all user data as untrusted and then santize it by: Encoding unsafe strings (e.g. HTML tags) Filtering unsafe elements (e.g., <sript> <a href=\"javascript://...\"> ) Rejecting strings that aren't explicitly safe patterns. This is generally not super easy: Encoding functions can be tricked. Different encodings can make it super hard to actually filter unsafe elements. Regular expressions are also hard to get right. You often trade off what kind of content users are allow to present with security (e.g., how do you write a blog post about XSS if any mention of <script> is disallowed?). HTML is generally hard to think about: different browsers parse things differently -- many are permissive to avoid breaking real pages. DOMPurify is a good way to sanitize content because it actually uses browser APIs to safely render the untrusted content. iframe sandbox \u00b6 The HTML iframe tag now has a sandbox attribute that can be used to sandbox untrusted content. For example, you can put content in an iframe sandbox where no script execution is allowed. CSP \u00b6 We'll talk about CSP more next week, but the short of it is: it lets you disable inline-scripts, whitelist scripts a page is allowed to execute, and whitelist trusted origins. (It really does way more than this, probably too much.) SQLi and other injections \u00b6 You don't need to only worry about sanitizing JS that will be sent to the client. Data is stored in databases, often by creating string queries. When you concatenating untrusted strings, the meaning of the query may change. For example, in Node.js, this is bad: ... const user = req.query.user; const query = `SELECT * FROM messages WHERE name = '${user}'`; ... db.query(query); Why? Attacker can end statement and insert their own code: What can you do with this? In general this is happening because of a mismatch: the web application treats user input as data database parser treats user input as code Other ways to inject \u00b6 There are many other places where user data can cause harm. Executing external binaries: when you call out to system() you want to make sure that the user data can't adversely affect the executable, arguments, etc. Reading/writing files: when you handle file uploads or read/write files on behalf of user, don't trust the filename. Defenses \u00b6 For SQLi you can sanitize user input, but this is generally no longer the recommend approach. Prepared statements are largely the norm: db.query({ text: 'SELECT * FROM messages WHERE name = '$1' , values: [user] }); The prepare text says which statement to execute and where the parameters are $1 . The values are provided separately and encoded by the database (not app). We sometimes still need to sanitize: if the data makes it back to client we need to sanitize/filter JavaScript. APIs for reading/writing files don't always have a prepared statment-like interface.","title":"CSRF, XSS, SQLi"},{"location":"notes/lecture13/#csrf","text":"The same origin policy does not prevent cross-origin requests from being sent. It only prevents you from processing/inspecting the response. So? If you're logged into bank.ch and bank.ch doesn't \"properly\" handle requests -- i.e., it only checks the cookie to make sure you're authenticated -- then evil.com can send a request to, say, transfer funds out of your account. For example, the attacker can send a POST request via an HTML <form> element or just use the XHR/fetch JavaScript APIs. In general POST requests are considered the most general because they inherently modify state server-side. But, some web sites take query parameters from a GET request and modify state server-side too (e.g., you can do forms this way just as well), and an attacker can just as easily abuse this.","title":"CSRF"},{"location":"notes/lecture13/#defenses","text":"Goal: server wants to make sure request is coming from same origin (or from an origin it trusts).","title":"Defenses"},{"location":"notes/lecture13/#csrf-tokens","text":"The most common way to deal with this is to create random token and include them in your forms as hidden values. Server-side, you can now just check that the request body (after praising) contains the right token. What happens if you forget to add token to form field? What happens if you forget to check tokens server-side? What do you do about GET requests? What's the trade-off? (How does this play with CDNs?)","title":"CSRF tokens"},{"location":"notes/lecture13/#referrer-and-origin-headers","text":"Browser sends referrer header to server to indicate what the URL of the page that made the request is. Full URL is not great for privacy and many organizations filter referrer headers. Origin header just includes the origin of the page. Mostly just for POST requests. Largely designed to deal with CSRF. Support for origin header not done in all browsers. What's the trade-off when comparsed to tokens?","title":"Referrer and origin headers"},{"location":"notes/lecture13/#xss","text":"XSS is a way of injecting scripts that execute client-side unintentionally.","title":"XSS"},{"location":"notes/lecture13/#stored-xxs","text":"A classical example of an XSS attack is a forum that renders HTML-sylized user comments. If the forum is not \"properly\" implemented -- i.e., if the server does not properly filter data -- a malcious user can upload a comment that contains a <script> element. Any other user that then views the page that contains the comment will then be pwned: the malicious script will run in the context of the victim web app. So, for example, the script can steal the user's cookie, leak data, etc. This is called a stored XSS attack because the script is stored in the form database and happily shipped to the client (browser) by the forum web app.","title":"Stored XXS"},{"location":"notes/lecture13/#reflected-xss","text":"This is not the only vector though. For example, this link https://duckduckgo.com/?q=xss when you click on it will not only navigate you to http://duckduckgo.com but also populate the search bar. If they didn't implement sanitization properly an attacker can craft a link that includes code. For example, they can set the query string to \"><script>alert('pwn')</script to close the <input value=\"...> field and add a script element. (Duckduckgo actually handles this so this won't work if you try it.) This XSS attack requires the victim to click on a link (or type in a URL, submit GET form, etc.). This is called a reflected XSS attacks , it takes advantage of the fact that the web site reflects what's in the URL on the page.","title":"Reflected XSS"},{"location":"notes/lecture13/#defenses_1","text":"","title":"Defenses"},{"location":"notes/lecture13/#sanitization","text":"The typical approach is to consider all user data as untrusted and then santize it by: Encoding unsafe strings (e.g. HTML tags) Filtering unsafe elements (e.g., <sript> <a href=\"javascript://...\"> ) Rejecting strings that aren't explicitly safe patterns. This is generally not super easy: Encoding functions can be tricked. Different encodings can make it super hard to actually filter unsafe elements. Regular expressions are also hard to get right. You often trade off what kind of content users are allow to present with security (e.g., how do you write a blog post about XSS if any mention of <script> is disallowed?). HTML is generally hard to think about: different browsers parse things differently -- many are permissive to avoid breaking real pages. DOMPurify is a good way to sanitize content because it actually uses browser APIs to safely render the untrusted content.","title":"Sanitization"},{"location":"notes/lecture13/#iframe-sandbox","text":"The HTML iframe tag now has a sandbox attribute that can be used to sandbox untrusted content. For example, you can put content in an iframe sandbox where no script execution is allowed.","title":"iframe sandbox"},{"location":"notes/lecture13/#csp","text":"We'll talk about CSP more next week, but the short of it is: it lets you disable inline-scripts, whitelist scripts a page is allowed to execute, and whitelist trusted origins. (It really does way more than this, probably too much.)","title":"CSP"},{"location":"notes/lecture13/#sqli-and-other-injections","text":"You don't need to only worry about sanitizing JS that will be sent to the client. Data is stored in databases, often by creating string queries. When you concatenating untrusted strings, the meaning of the query may change. For example, in Node.js, this is bad: ... const user = req.query.user; const query = `SELECT * FROM messages WHERE name = '${user}'`; ... db.query(query); Why? Attacker can end statement and insert their own code: What can you do with this? In general this is happening because of a mismatch: the web application treats user input as data database parser treats user input as code","title":"SQLi and other injections"},{"location":"notes/lecture13/#other-ways-to-inject","text":"There are many other places where user data can cause harm. Executing external binaries: when you call out to system() you want to make sure that the user data can't adversely affect the executable, arguments, etc. Reading/writing files: when you handle file uploads or read/write files on behalf of user, don't trust the filename.","title":"Other ways to inject"},{"location":"notes/lecture13/#defenses_2","text":"For SQLi you can sanitize user input, but this is generally no longer the recommend approach. Prepared statements are largely the norm: db.query({ text: 'SELECT * FROM messages WHERE name = '$1' , values: [user] }); The prepare text says which statement to execute and where the parameters are $1 . The values are provided separately and encoded by the database (not app). We sometimes still need to sanitize: if the data makes it back to client we need to sanitize/filter JavaScript. APIs for reading/writing files don't always have a prepared statment-like interface.","title":"Defenses"},{"location":"pa/pa1/","text":"Assignment 1 (20 pts) \u00b6 Deadline: Sunday, January 27, 2019 by 11:59:59 PM Early Turn-In: Thursday, January 24, 2019 by 11:59:59 PM (10% bonus) The goal of this assignment is to become familiar with the setup that will be used for future assignments, such as the use of a virtual machine and the included turn-in script, as well as the basics of working with gdb and writing programs in x86 assembly. Getting Started \u00b6 To complete this assignment, you will be provided with a VirtualBox VM pre-populated with the assignment files and a turn-in script. VM Image \u00b6 In order to match the environment in which your submission will be graded, all work for this assignment must be done on the VirtualBox VM we provide, named pa1box . You can download the VM image here . The VM is configured with two users: student , with password hacktheplanet ; and root , with password hackallthethings . The VM is configured with SSH on port 2222. Please note that SSH is disabled for root , so you can only SSH in as the student user. You can still log in as root using su or by logging into the VM directly. To SSH into the VM: ssh -p 2222 student@127.0.0.1 To copy files from your computer to the VM: scp -P 2222 -r /path/to/files/ student@127.0.0.1:/home/student To copy files from the VM to your computer: scp -P 2222 student@127.0.0.1:/path/to/files/ /destination/path Part 1: Using GDB (10 pts) \u00b6 Files for this sub-assignment are located in the gdb subdirectory of the student user's home directory in the VM image; that is, /home/student/gdb . SSH into the VM and cd into that directory to begin working on it. Inside the gdb directory, you'll find fib.c , a C program demonstrating the Fibonacci sequence; a Makefile ; and hw1.txt , in which you'll record your responses to the questions below. The first step is to compile fib by running make on the command line. To run the fib executable in GDB, run gdb -e fib . Use the -s option to load a symbol file. I recommend the following workflow in GDB: Starting. Set breakpoints that you can later use for analysis: b foo \u2014 break at function foo b *0x08048489 \u2014 break at the instruction at address 0x08048489 r \u2014 run the executable Analyzing. Examine memory, registers, etc; disassemble code; show stack frames, backtrace, etc; and more: disas foo \u2014 disassemble function foo i r \u2014 view registers where \u2014 view stack frames x <loc> \u2014 examine memory x $eip \u2014 examine current instruction pointer x /10x $esp \u2014 examine 10 words at top of stack x /10x buf \u2014 examine 10 words in buf x /10i $eip \u2014 examine 10 instructions starting at instruction pointer x /10i foo \u2014 examine 10 instructions starting at foo Continuing. Continue analysis: c \u2014 continue execution until next breakpoint/watchpoint si \u2014 step to the next instruction s \u2014 step to the next line of source code Note that this is only a cursory overview of GDB; much more info is available from online resources. Assignment Instructions \u00b6 Complete the following exercises and fill out hw1.txt with your answers. What is the value, in hex, of the ecx register when the function f is called? (2 pts) Which register stores the value of the variable i in the function main? (2 pts) What is the address, in hex, of the function f ? (2 pts) What is the name of the 6th instruction of the function f ? (2 pts) When f completes after being called from main , to which address in main does control return? Write your answer in hex form. (2 pts) Submission \u00b6 To submit your solution for this sub-assignment, run the gradinator-submit command from the /home/student/gdb directory and follow the prompts that appear. You may submit as many times as you like ahead of the deadline, but only your most recent submission will be counted. Grades for this part of the assignment will be released after the deadline has passed. Note that part 1 (gdb) and part 2 (x86) must be submitted separately . Part 2: echo in x86 (10 pts) \u00b6 Files for this sub-assignment are located in the x86 subdirectory of the student user's home directory in the VM image; that is, /home/student/x86 . SSH into the VM and cd into that directory to begin working on it. For this part, you will be implementing a simplified version of the familiar echo command, using raw x86 assembly code. The goal of this assignment is to familiarize you with writing programs directly in x86. Your echo command must behave as follows: When run with a single command line argument (e.g., ./echo Hello ): Prints that argument back to the console's standard output (stdout). Prints a trailing newline ( \\n ). Exits with code 0. When run with too few command line arguments (e.g., ./echo ) or too many (e.g., ./echo Hello World ): Prints exactly the error message This command expects exactly one argument. \u2014 followed by a trailing newline ( \\n ) \u2014 to the console's standard error (stderr). Exits with code 1. Your code should be written in the file echo.s inside the x86 directory. A heavily-commented example echo.s is provided, which simply prints the message Hello World (followed by a trailing newline) to stdout. Your job is to modify this program to meet the specification for echo above. A Makefile is included, so you can build the echo binary by running make from the command line. Helpful Hints \u00b6 In a Linux program, stdout is file descriptor number 1 and stderr is number 2. Linux programs start with argc at the top of the stack, accessible at 0(%esp) from x86-assembly programs. Below it is argv , the array of pointers to (null-terminated) strings passed into the program as arguments. So argv[0] can be accessed from x86-assembly programs at 4(%esp) , argv[1] at 8(%esp) , argv[2] at 12(%esp) , and so on. argv[0] is the name of the program executed, not the first argument, which is argv[1] if supplied (or 8(%esp) for our purposes). Then argc (or 0(%esp) ) will be 1 if the program was not passed any arguments, 2 if it was passed 1 argument, and so on. This table of Linux system calls may come in handy. Submission \u00b6 To submit your solution for this sub-assignment, run the gradinator-submit command from the /home/student/x86 directory and follow the prompts that appear. You may submit as many times as you like ahead of the deadline, but only your most recent submission will be counted. Note that part 1 (gdb) and part 2 (x86) must be submitted separately . For this part, after submitting an attempted solution, you'll subsequently receive a message from our auto-grading server to your email address associated with this class. The email will contain a breakdown of the steps it took to grade your assignment, points earned (or not) at each step, and a total score which\u2014apart from exceptional circumstances\u2014you can consider your final grade for this sub-assignment. Bugs \u00b6 If you find a bug in this assignment please create an issue here .","title":"Assignment 1"},{"location":"pa/pa1/#assignment-1-20-pts","text":"Deadline: Sunday, January 27, 2019 by 11:59:59 PM Early Turn-In: Thursday, January 24, 2019 by 11:59:59 PM (10% bonus) The goal of this assignment is to become familiar with the setup that will be used for future assignments, such as the use of a virtual machine and the included turn-in script, as well as the basics of working with gdb and writing programs in x86 assembly.","title":"Assignment 1 (20 pts)"},{"location":"pa/pa1/#getting-started","text":"To complete this assignment, you will be provided with a VirtualBox VM pre-populated with the assignment files and a turn-in script.","title":"Getting Started"},{"location":"pa/pa1/#vm-image","text":"In order to match the environment in which your submission will be graded, all work for this assignment must be done on the VirtualBox VM we provide, named pa1box . You can download the VM image here . The VM is configured with two users: student , with password hacktheplanet ; and root , with password hackallthethings . The VM is configured with SSH on port 2222. Please note that SSH is disabled for root , so you can only SSH in as the student user. You can still log in as root using su or by logging into the VM directly. To SSH into the VM: ssh -p 2222 student@127.0.0.1 To copy files from your computer to the VM: scp -P 2222 -r /path/to/files/ student@127.0.0.1:/home/student To copy files from the VM to your computer: scp -P 2222 student@127.0.0.1:/path/to/files/ /destination/path","title":"VM Image"},{"location":"pa/pa1/#part-1-using-gdb-10-pts","text":"Files for this sub-assignment are located in the gdb subdirectory of the student user's home directory in the VM image; that is, /home/student/gdb . SSH into the VM and cd into that directory to begin working on it. Inside the gdb directory, you'll find fib.c , a C program demonstrating the Fibonacci sequence; a Makefile ; and hw1.txt , in which you'll record your responses to the questions below. The first step is to compile fib by running make on the command line. To run the fib executable in GDB, run gdb -e fib . Use the -s option to load a symbol file. I recommend the following workflow in GDB: Starting. Set breakpoints that you can later use for analysis: b foo \u2014 break at function foo b *0x08048489 \u2014 break at the instruction at address 0x08048489 r \u2014 run the executable Analyzing. Examine memory, registers, etc; disassemble code; show stack frames, backtrace, etc; and more: disas foo \u2014 disassemble function foo i r \u2014 view registers where \u2014 view stack frames x <loc> \u2014 examine memory x $eip \u2014 examine current instruction pointer x /10x $esp \u2014 examine 10 words at top of stack x /10x buf \u2014 examine 10 words in buf x /10i $eip \u2014 examine 10 instructions starting at instruction pointer x /10i foo \u2014 examine 10 instructions starting at foo Continuing. Continue analysis: c \u2014 continue execution until next breakpoint/watchpoint si \u2014 step to the next instruction s \u2014 step to the next line of source code Note that this is only a cursory overview of GDB; much more info is available from online resources.","title":"Part 1: Using GDB (10 pts)"},{"location":"pa/pa1/#assignment-instructions","text":"Complete the following exercises and fill out hw1.txt with your answers. What is the value, in hex, of the ecx register when the function f is called? (2 pts) Which register stores the value of the variable i in the function main? (2 pts) What is the address, in hex, of the function f ? (2 pts) What is the name of the 6th instruction of the function f ? (2 pts) When f completes after being called from main , to which address in main does control return? Write your answer in hex form. (2 pts)","title":"Assignment Instructions"},{"location":"pa/pa1/#submission","text":"To submit your solution for this sub-assignment, run the gradinator-submit command from the /home/student/gdb directory and follow the prompts that appear. You may submit as many times as you like ahead of the deadline, but only your most recent submission will be counted. Grades for this part of the assignment will be released after the deadline has passed. Note that part 1 (gdb) and part 2 (x86) must be submitted separately .","title":"Submission"},{"location":"pa/pa1/#part-2-echo-in-x86-10-pts","text":"Files for this sub-assignment are located in the x86 subdirectory of the student user's home directory in the VM image; that is, /home/student/x86 . SSH into the VM and cd into that directory to begin working on it. For this part, you will be implementing a simplified version of the familiar echo command, using raw x86 assembly code. The goal of this assignment is to familiarize you with writing programs directly in x86. Your echo command must behave as follows: When run with a single command line argument (e.g., ./echo Hello ): Prints that argument back to the console's standard output (stdout). Prints a trailing newline ( \\n ). Exits with code 0. When run with too few command line arguments (e.g., ./echo ) or too many (e.g., ./echo Hello World ): Prints exactly the error message This command expects exactly one argument. \u2014 followed by a trailing newline ( \\n ) \u2014 to the console's standard error (stderr). Exits with code 1. Your code should be written in the file echo.s inside the x86 directory. A heavily-commented example echo.s is provided, which simply prints the message Hello World (followed by a trailing newline) to stdout. Your job is to modify this program to meet the specification for echo above. A Makefile is included, so you can build the echo binary by running make from the command line.","title":"Part 2: echo in x86 (10 pts)"},{"location":"pa/pa1/#helpful-hints","text":"In a Linux program, stdout is file descriptor number 1 and stderr is number 2. Linux programs start with argc at the top of the stack, accessible at 0(%esp) from x86-assembly programs. Below it is argv , the array of pointers to (null-terminated) strings passed into the program as arguments. So argv[0] can be accessed from x86-assembly programs at 4(%esp) , argv[1] at 8(%esp) , argv[2] at 12(%esp) , and so on. argv[0] is the name of the program executed, not the first argument, which is argv[1] if supplied (or 8(%esp) for our purposes). Then argc (or 0(%esp) ) will be 1 if the program was not passed any arguments, 2 if it was passed 1 argument, and so on. This table of Linux system calls may come in handy.","title":"Helpful Hints"},{"location":"pa/pa1/#submission_1","text":"To submit your solution for this sub-assignment, run the gradinator-submit command from the /home/student/x86 directory and follow the prompts that appear. You may submit as many times as you like ahead of the deadline, but only your most recent submission will be counted. Note that part 1 (gdb) and part 2 (x86) must be submitted separately . For this part, after submitting an attempted solution, you'll subsequently receive a message from our auto-grading server to your email address associated with this class. The email will contain a breakdown of the steps it took to grade your assignment, points earned (or not) at each step, and a total score which\u2014apart from exceptional circumstances\u2014you can consider your final grade for this sub-assignment.","title":"Submission"},{"location":"pa/pa1/#bugs","text":"If you find a bug in this assignment please create an issue here .","title":"Bugs"},{"location":"pa/pa2/","text":"Assignment 2 75 pts + 25pts extra for sploit4 \u00b6 Deadline: Sunday, February 10, 2019 by 11:59:59 PM Early Turn-In: Thursday, February 7, 2019 by 11:59:59 PM (10% bonus) The goal of this assignment is to gain hands-on experience with the effects of buffer overflows and other memory-safety bugs. You will be provided a skeleton for implementing these exploits in C. You must not discuss your solution with other students until three days after the assignment deadline. You may consult any online references you wish. If you use any code in your answer that you did not write yourself, you must document that fact. Failure to do so will be considered a violation of the academic integrity policy. Getting Started \u00b6 To complete this assignment you will be provided with a VirtualBox VM and a set of files including a turn-in script. VM Image \u00b6 In order to match the environment in which your submission will be graded, all work for this assignment must be done on the VirtualBox VM we have provided, named pa2box . You can download the VM image here . Import the pa2box.vbox file into VirtualBox via the Machine \u2192 Add menu item. Don't create a brand-new VirtualBox VM or import the pa2box-data.vmdk file on its own: if you do this, you won't have the correct configuration. After importing the VM, select it in the VirtualBox sidebar and start it with the green arrow button or the Machine \u2192 Start menu item. The VM is configured with two users: student , with password hacktheplanet ; and root , with password hackallthethings . Instead of using the command line through VirtualBox, we recommend that you SSH into your VM from another client. The VM image is configured to expose an SSH server on port 2222 of your system's loopback address ( 127.0.0.1 ). To SSH into the VM (from your host system running VirtualBox, not from inside the VM): ssh -p 2222 student@127.0.0.1 To copy files from your computer to the VM: scp -P 2222 -r /path/to/files/ student@127.0.0.1:/home/student To copy files from the VM to your computer: scp -P 2222 student@127.0.0.1:/path/to/files/ /destination/path Please note that SSH is disabled for root , so you can only SSH in as the student user. You can still log in as root using su or by logging into the VM directly. Assignment Files \u00b6 Starter files are included inside the student home directory of the VM image. The targets directory contains a Makefile to generate target executables specific to your PID (as well as a folder called base , which you should not modify, used to generate the targets). Exploit starter code can be found in the sploits1 - sploits4 directories: one per each of the four vulnerable target programs. Each of these contains a Makefile , a shellcode.h header file providing Aleph One's shellcode, and a sploitN.c file in which you should write your exploit code (in addition to an assignment.toml file, which should not be modified). You will be writing an exploit for each of the four vulnerable programs provided in the assignment. Each exploit, when run in the VM with its target installed setuid-root in /tmp , should yield a root shell ( /bin/sh ). You can verify that the shell has been launched as root by typing whoami , to which you should see the response root . You must use Aleph One\u2019s shellcode in shellcode.h , as this will be used in the grading scripts. For each exploit, in addition to your .c file, please also create a corresponding file writeup.txt containing a brief description of how the exploit works. Exploit Generation \u00b6 To complete the assignment, you will need to: generate targets specific to your PID; use GDB to find vulnerabilities in the targets; and, finally, craft your exploit programs. Generating the Targets \u00b6 Run make generate in the targets directory to create the four target source files specific to you. This will prompt you for your student ID ( A######## or U######## ), which will be used to randomize portions of the contents of target1.c - target4.c . Run make to build the target binaries target1 - target4 . Run sudo make install to copy the binaries into the /tmp directory. Finally, run sudo make setuid to mark the binaries as setuid-root. If you forget this step, then your exploits will end up launching a normal shell instead of a root shell! Using GDB \u00b6 To run an exploit in GDB, run, e.g., gdb -e sploit1 -s /tmp/target1 to execute sploit1 and use the symbol file target1 . We recommend the following workflow in GDB: Starting. Set breakpoints that you can later use for analysis: b foo \u2014 break at function foo b *0x08048489 \u2014 break at the instruction at address 0x08048489 r \u2014 run the executable Analyzing. Examine memory, registers, etc; disassemble code; show stack frames, backtrace, etc; and more: disas foo \u2014 disassemble function foo i r \u2014 view registers where \u2014 view stack frames x <loc> \u2014 examine memory x $eip \u2014 examine current instruction pointer x /10x $esp \u2014 examine 10 words at top of stack x /10x buf \u2014 examine 10 words in buf x /10i $eip \u2014 examine 10 instructions starting at instruction pointer x /10i foo \u2014 examine 10 instructions starting at foo Continuing. Continue analysis: c \u2014 continue execution until next breakpoint/watchpoint si \u2014 step to the next instruction s \u2014 step to the next line of source code Note that this is only a cursory overview of GDB; much more info is available from online resources. Exploit Notes \u00b6 For this assignment you should read and have a solid understanding of Aleph One\u2019s \u201cSmashing the Stack for Fun and Profit\u201d. Aleph One gives code that calculates addresses on the target\u2019s stack based on addresses on the exploit\u2019s stack. However, addresses on the exploit\u2019s stack can change based on how the exploit is executed (working directory, arguments, environment, etc.). You must therefore hard-code target stack locations in your exploits. You should not use a function such as get_sp() in the exploits you hand in. You should only modify the sploitN.c files and corresponding writeup.txt files; i.e., your exploits should work with unmodified Makefiles, targets, etc. In grading, the exploits may be run with a different environment and different working directory. Your exploits must work in these cases also. Your exploit programs should not take any command-line arguments. Shutting down the VM removes the files in /tmp; if you want to keep them, pause the VM and save its state! Submission \u00b6 To submit your solution for each sub-assignment, run the gradinator-submit command from the corresponding sploit1 - sploit4 directory and follow the prompts that appear. You may submit as many times as you like ahead of the deadline, but only your most recent submission will be counted. Note that each of the four sub-assignments must be submitted separately . For each sub-assignment, after submitting an attempted solution, you'll subsequently receive a message from our auto-grading server to your email address associated with this class. The email will contain a breakdown of the steps it took to grade your assignment, points earned (or not) at each step, and a total score for that sub-assignment. Each one is worth 25 points.","title":"Assignment 2"},{"location":"pa/pa2/#assignment-2-75-pts-25pts-extra-for-sploit4","text":"Deadline: Sunday, February 10, 2019 by 11:59:59 PM Early Turn-In: Thursday, February 7, 2019 by 11:59:59 PM (10% bonus) The goal of this assignment is to gain hands-on experience with the effects of buffer overflows and other memory-safety bugs. You will be provided a skeleton for implementing these exploits in C. You must not discuss your solution with other students until three days after the assignment deadline. You may consult any online references you wish. If you use any code in your answer that you did not write yourself, you must document that fact. Failure to do so will be considered a violation of the academic integrity policy.","title":"Assignment 2 75 pts + 25pts extra for sploit4"},{"location":"pa/pa2/#getting-started","text":"To complete this assignment you will be provided with a VirtualBox VM and a set of files including a turn-in script.","title":"Getting Started"},{"location":"pa/pa2/#vm-image","text":"In order to match the environment in which your submission will be graded, all work for this assignment must be done on the VirtualBox VM we have provided, named pa2box . You can download the VM image here . Import the pa2box.vbox file into VirtualBox via the Machine \u2192 Add menu item. Don't create a brand-new VirtualBox VM or import the pa2box-data.vmdk file on its own: if you do this, you won't have the correct configuration. After importing the VM, select it in the VirtualBox sidebar and start it with the green arrow button or the Machine \u2192 Start menu item. The VM is configured with two users: student , with password hacktheplanet ; and root , with password hackallthethings . Instead of using the command line through VirtualBox, we recommend that you SSH into your VM from another client. The VM image is configured to expose an SSH server on port 2222 of your system's loopback address ( 127.0.0.1 ). To SSH into the VM (from your host system running VirtualBox, not from inside the VM): ssh -p 2222 student@127.0.0.1 To copy files from your computer to the VM: scp -P 2222 -r /path/to/files/ student@127.0.0.1:/home/student To copy files from the VM to your computer: scp -P 2222 student@127.0.0.1:/path/to/files/ /destination/path Please note that SSH is disabled for root , so you can only SSH in as the student user. You can still log in as root using su or by logging into the VM directly.","title":"VM Image"},{"location":"pa/pa2/#assignment-files","text":"Starter files are included inside the student home directory of the VM image. The targets directory contains a Makefile to generate target executables specific to your PID (as well as a folder called base , which you should not modify, used to generate the targets). Exploit starter code can be found in the sploits1 - sploits4 directories: one per each of the four vulnerable target programs. Each of these contains a Makefile , a shellcode.h header file providing Aleph One's shellcode, and a sploitN.c file in which you should write your exploit code (in addition to an assignment.toml file, which should not be modified). You will be writing an exploit for each of the four vulnerable programs provided in the assignment. Each exploit, when run in the VM with its target installed setuid-root in /tmp , should yield a root shell ( /bin/sh ). You can verify that the shell has been launched as root by typing whoami , to which you should see the response root . You must use Aleph One\u2019s shellcode in shellcode.h , as this will be used in the grading scripts. For each exploit, in addition to your .c file, please also create a corresponding file writeup.txt containing a brief description of how the exploit works.","title":"Assignment Files"},{"location":"pa/pa2/#exploit-generation","text":"To complete the assignment, you will need to: generate targets specific to your PID; use GDB to find vulnerabilities in the targets; and, finally, craft your exploit programs.","title":"Exploit Generation"},{"location":"pa/pa2/#generating-the-targets","text":"Run make generate in the targets directory to create the four target source files specific to you. This will prompt you for your student ID ( A######## or U######## ), which will be used to randomize portions of the contents of target1.c - target4.c . Run make to build the target binaries target1 - target4 . Run sudo make install to copy the binaries into the /tmp directory. Finally, run sudo make setuid to mark the binaries as setuid-root. If you forget this step, then your exploits will end up launching a normal shell instead of a root shell!","title":"Generating the Targets"},{"location":"pa/pa2/#using-gdb","text":"To run an exploit in GDB, run, e.g., gdb -e sploit1 -s /tmp/target1 to execute sploit1 and use the symbol file target1 . We recommend the following workflow in GDB: Starting. Set breakpoints that you can later use for analysis: b foo \u2014 break at function foo b *0x08048489 \u2014 break at the instruction at address 0x08048489 r \u2014 run the executable Analyzing. Examine memory, registers, etc; disassemble code; show stack frames, backtrace, etc; and more: disas foo \u2014 disassemble function foo i r \u2014 view registers where \u2014 view stack frames x <loc> \u2014 examine memory x $eip \u2014 examine current instruction pointer x /10x $esp \u2014 examine 10 words at top of stack x /10x buf \u2014 examine 10 words in buf x /10i $eip \u2014 examine 10 instructions starting at instruction pointer x /10i foo \u2014 examine 10 instructions starting at foo Continuing. Continue analysis: c \u2014 continue execution until next breakpoint/watchpoint si \u2014 step to the next instruction s \u2014 step to the next line of source code Note that this is only a cursory overview of GDB; much more info is available from online resources.","title":"Using GDB"},{"location":"pa/pa2/#exploit-notes","text":"For this assignment you should read and have a solid understanding of Aleph One\u2019s \u201cSmashing the Stack for Fun and Profit\u201d. Aleph One gives code that calculates addresses on the target\u2019s stack based on addresses on the exploit\u2019s stack. However, addresses on the exploit\u2019s stack can change based on how the exploit is executed (working directory, arguments, environment, etc.). You must therefore hard-code target stack locations in your exploits. You should not use a function such as get_sp() in the exploits you hand in. You should only modify the sploitN.c files and corresponding writeup.txt files; i.e., your exploits should work with unmodified Makefiles, targets, etc. In grading, the exploits may be run with a different environment and different working directory. Your exploits must work in these cases also. Your exploit programs should not take any command-line arguments. Shutting down the VM removes the files in /tmp; if you want to keep them, pause the VM and save its state!","title":"Exploit Notes"},{"location":"pa/pa2/#submission","text":"To submit your solution for each sub-assignment, run the gradinator-submit command from the corresponding sploit1 - sploit4 directory and follow the prompts that appear. You may submit as many times as you like ahead of the deadline, but only your most recent submission will be counted. Note that each of the four sub-assignments must be submitted separately . For each sub-assignment, after submitting an attempted solution, you'll subsequently receive a message from our auto-grading server to your email address associated with this class. The email will contain a breakdown of the steps it took to grade your assignment, points earned (or not) at each step, and a total score for that sub-assignment. Each one is worth 25 points.","title":"Submission"},{"location":"pa/pa3/","text":"Assignment 3 100pts \u00b6 Deadline: Thursday, March 7, 2019 by 11:59:59 PM Early Turn-In: Monday, March 4, 2019 by 11:59:59 PM (10% bonus) The goal of this assignment is to gain hands-on experience exploiting side channels. This assignment will demonstrate how side channels can be just as dangerous as the control flow vulnerabilities you exploited in Assignment 2. You will be provided a two skeleton files ( memhack.c and timehack.c ) that you will use to exploit side channels present in a target library ( sysapp.c ) to obtain a protected key. You may consult any online references you wish. If you use any code in your answer that you did not write yourselves, you must document that fact. Failure to do so will be considered a violation of the academic integrity policy. Getting Started \u00b6 To complete this assignment you will be provided with a VirtualBox VM and a set of files including a turn-in script. VM Image \u00b6 In order to match the environment in which your submission will be graded, all work for this assignment must be done on the VirtualBox VM we have provided, named pa3box . You can download the VM image here . Import the pa3box.vbox file into VirtualBox via the Machine \u2192 Add menu item. Don't create a brand-new VirtualBox VM or import the pa3box-data.vmdk file on its own: if you do this, you won't have the correct configuration. After importing the VM, select it in the VirtualBox sidebar and start it with the green arrow button or the Machine \u2192 Start menu item. The VM is configured with two users: student , with password hacktheplanet ; and root , with password hackallthethings . Instead of using the command line through VirtualBox, we recommend that you SSH into your VM from another client. The VM image is configured to expose an SSH server on port 2222 of your system's loopback address ( 127.0.0.1 ). To SSH into the VM (from your host system running VirtualBox, not from inside the VM): ssh -p 2222 student@127.0.0.1 To copy files from your computer to the VM: scp -P 2222 -r /path/to/files/ student@127.0.0.1:/home/student To copy files from the VM to your computer: scp -P 2222 student@127.0.0.1:/path/to/files/ /destination/path Please note that SSH is disabled for root , so you can only SSH in as the student user. You can still log in as root using su or by logging into the VM directly. Assignment Files \u00b6 Starter files are included inside the student user's home directory within the VM image. There are two parts to this assignment, each with its own subdirectory, memhack and timehack . Each subdirectory contains exploit starter code ( memhack.c or timehack.c ), which imports a library ( sysapp.c , with the same contents across the two subdirectories) with password-checking functionality vulnerable to side-channel attacks. You should not modify sysapp.c , only memhack.c and timehack.c . Each subdirectory contains a Makefile for building your exploits. Assignment Instructions \u00b6 You will be writing two exploits, each of which takes advantage of a side channel, to obtain the password in sysapp.c . In memhack.c , you will exploit a memory-based side channel, and in timehack.c you will exploit a timing-based side channel. See Section 2 for specific details. Once both of your exploits can determine the password in sysapp.c and call the hack_system() function successfully, the assignment is complete. Additionally, for each exploit, provide a brief description of how it works in its corresponding writeup.txt file. Submitting Your Solutions \u00b6 To submit your solution for each sub-assignment, run the gradinator-submit command from the corresponding memhack or timehack subdirectory and follow the prompts that appear. You may submit as many times as you like ahead of the deadline, but only your most recent submission will be counted. Note that each of the two sub-assignments must be submitted separately . For each sub-assignment, after submitting an attempted solution, you'll subsequently receive a message from our auto-grading server to your email address associated with this class. The email will contain a breakdown of the steps it took to grade your assignment, points earned (or not) at each step, and a total score for that sub-assignment. Each one is worth 50 points. Exploit Construction \u00b6 Memory-Based Side Channel \u00b6 We recommend you start with the memory-based side channel because it is deterministic and doesn't have problems with noise. Look at the check_pass() function in sysapp.c and note two things: The password string is passed by reference The memory it points to is checked against the reference password one character at a time. Now look in memhack.c and note how a buffer is allocated such that the page starting at page start is protected (i.e., accessing it will caused a segmentation fault, or SEGV) and the previous 32 characters are allocated. Now look at the demonstration function demonstrate_signals() , which shows how referencing any memory in the protected page will produce a fault as well as how to catch that fault in your program. You do not need to use this function; it is merely there to show you how to use signals to capture whether a memory reference touched a page or not. Now you will want to create a framework (in memhack.c ) to call check_pass() with different inputs and catching any resulting faults so you can determine if part of the password is correct. We suggest a loop over the maximum password size (32 characters) where for the first guess you store the password such that its first character is one byte before page start and then iterate between possible choices for the first character (when you get it right you will get a page fault). Repeat this to guess the entire password. Note that all ASCII symbols from ASCII 33 ( ! ) to ASCII 126 ( \u223c ) can be used in the password. Other hints: You are already given a page protected buffer with enough memory to crack the password. All you need to do is use it appropriately for each guess you make. The demonstrate_signals function handles all the segfaults for you. You can re-use almost all of it in your code. Timing-Based Side Channel \u00b6 Unlike the memory-based side channel, the timing-based side channel will deal with noise. Go back and look at check_pass() . An artificial delay has been added when each character is checked to make your life easier (it\u2019s possible to do the assignment without it but it would require a much more careful methodology). The execution time of check_pass() depends on how many characters you guess correctly . Look in timehack.c and find a macro there for a function called rdtsc() which invokes the processors cycle counter (a clock that increments by one for each processor cycle that passes). In general, treat rdtsc() as a free running timer that returns a long . Insert a call to rdtsc() before the call to check_pass() and afterwards. Print the difference between these values to see how long (in cycles) the password checking ran. Run the program a few times. Now change the guess string so the first character is correct. Run again and see how the time difference changes. Now automate this entire process, in the style of the original approach in memhack.c . Note that unlike the memhack attack, the timehack problem will have to deal with noise . Depending on things like what other programs are running, the status of the cache, the contents of the branch target buffer, etc... there can be significant variability in the amount of time each check takes. This will matter in practice. You will want to run a lot of trials before you reach your conclusion about each character. Other hints: Be careful in using printf \u2019s. These can blow out the instruction cache and data caches and perturb your results (i.e. overwhelm the timing effects you are trying to detect). Be careful in averaging across trials. If your process is descheduled in the middle of a measurement, the time cost of that individual trial will be so large that it overwhelms everything else. Instead, the median is your friend. However, feel free to experiment if something does not work for you. If time is not continuing to increase as you progress through characters, then you probably made a bad guess earlier. Backtrack. rdtsc() will wrap around at some point. You may need to handle this outlier if it is causing issues. Debugging advice: make a big array to hold your timing measurements and print them at the end. Be sure to test a bunch of different passwords. We will when we grade. Final Notes \u00b6 Do not write a solution that simply checks all passwords exhaustively. You will not get credit for this. This should be doable in linear time (we will stop programs that are running for excessive periods) and it will basically feel instantaneous for passwords of 8 characters or less (note we will not test passwords over 12 characters). We plan to do the testing/evaluation on our server.","title":"Assignment 3"},{"location":"pa/pa3/#assignment-3-100pts","text":"Deadline: Thursday, March 7, 2019 by 11:59:59 PM Early Turn-In: Monday, March 4, 2019 by 11:59:59 PM (10% bonus) The goal of this assignment is to gain hands-on experience exploiting side channels. This assignment will demonstrate how side channels can be just as dangerous as the control flow vulnerabilities you exploited in Assignment 2. You will be provided a two skeleton files ( memhack.c and timehack.c ) that you will use to exploit side channels present in a target library ( sysapp.c ) to obtain a protected key. You may consult any online references you wish. If you use any code in your answer that you did not write yourselves, you must document that fact. Failure to do so will be considered a violation of the academic integrity policy.","title":"Assignment 3 100pts"},{"location":"pa/pa3/#getting-started","text":"To complete this assignment you will be provided with a VirtualBox VM and a set of files including a turn-in script.","title":"Getting Started"},{"location":"pa/pa3/#vm-image","text":"In order to match the environment in which your submission will be graded, all work for this assignment must be done on the VirtualBox VM we have provided, named pa3box . You can download the VM image here . Import the pa3box.vbox file into VirtualBox via the Machine \u2192 Add menu item. Don't create a brand-new VirtualBox VM or import the pa3box-data.vmdk file on its own: if you do this, you won't have the correct configuration. After importing the VM, select it in the VirtualBox sidebar and start it with the green arrow button or the Machine \u2192 Start menu item. The VM is configured with two users: student , with password hacktheplanet ; and root , with password hackallthethings . Instead of using the command line through VirtualBox, we recommend that you SSH into your VM from another client. The VM image is configured to expose an SSH server on port 2222 of your system's loopback address ( 127.0.0.1 ). To SSH into the VM (from your host system running VirtualBox, not from inside the VM): ssh -p 2222 student@127.0.0.1 To copy files from your computer to the VM: scp -P 2222 -r /path/to/files/ student@127.0.0.1:/home/student To copy files from the VM to your computer: scp -P 2222 student@127.0.0.1:/path/to/files/ /destination/path Please note that SSH is disabled for root , so you can only SSH in as the student user. You can still log in as root using su or by logging into the VM directly.","title":"VM Image"},{"location":"pa/pa3/#assignment-files","text":"Starter files are included inside the student user's home directory within the VM image. There are two parts to this assignment, each with its own subdirectory, memhack and timehack . Each subdirectory contains exploit starter code ( memhack.c or timehack.c ), which imports a library ( sysapp.c , with the same contents across the two subdirectories) with password-checking functionality vulnerable to side-channel attacks. You should not modify sysapp.c , only memhack.c and timehack.c . Each subdirectory contains a Makefile for building your exploits.","title":"Assignment Files"},{"location":"pa/pa3/#assignment-instructions","text":"You will be writing two exploits, each of which takes advantage of a side channel, to obtain the password in sysapp.c . In memhack.c , you will exploit a memory-based side channel, and in timehack.c you will exploit a timing-based side channel. See Section 2 for specific details. Once both of your exploits can determine the password in sysapp.c and call the hack_system() function successfully, the assignment is complete. Additionally, for each exploit, provide a brief description of how it works in its corresponding writeup.txt file.","title":"Assignment Instructions"},{"location":"pa/pa3/#submitting-your-solutions","text":"To submit your solution for each sub-assignment, run the gradinator-submit command from the corresponding memhack or timehack subdirectory and follow the prompts that appear. You may submit as many times as you like ahead of the deadline, but only your most recent submission will be counted. Note that each of the two sub-assignments must be submitted separately . For each sub-assignment, after submitting an attempted solution, you'll subsequently receive a message from our auto-grading server to your email address associated with this class. The email will contain a breakdown of the steps it took to grade your assignment, points earned (or not) at each step, and a total score for that sub-assignment. Each one is worth 50 points.","title":"Submitting Your Solutions"},{"location":"pa/pa3/#exploit-construction","text":"","title":"Exploit Construction"},{"location":"pa/pa3/#memory-based-side-channel","text":"We recommend you start with the memory-based side channel because it is deterministic and doesn't have problems with noise. Look at the check_pass() function in sysapp.c and note two things: The password string is passed by reference The memory it points to is checked against the reference password one character at a time. Now look in memhack.c and note how a buffer is allocated such that the page starting at page start is protected (i.e., accessing it will caused a segmentation fault, or SEGV) and the previous 32 characters are allocated. Now look at the demonstration function demonstrate_signals() , which shows how referencing any memory in the protected page will produce a fault as well as how to catch that fault in your program. You do not need to use this function; it is merely there to show you how to use signals to capture whether a memory reference touched a page or not. Now you will want to create a framework (in memhack.c ) to call check_pass() with different inputs and catching any resulting faults so you can determine if part of the password is correct. We suggest a loop over the maximum password size (32 characters) where for the first guess you store the password such that its first character is one byte before page start and then iterate between possible choices for the first character (when you get it right you will get a page fault). Repeat this to guess the entire password. Note that all ASCII symbols from ASCII 33 ( ! ) to ASCII 126 ( \u223c ) can be used in the password. Other hints: You are already given a page protected buffer with enough memory to crack the password. All you need to do is use it appropriately for each guess you make. The demonstrate_signals function handles all the segfaults for you. You can re-use almost all of it in your code.","title":"Memory-Based Side Channel"},{"location":"pa/pa3/#timing-based-side-channel","text":"Unlike the memory-based side channel, the timing-based side channel will deal with noise. Go back and look at check_pass() . An artificial delay has been added when each character is checked to make your life easier (it\u2019s possible to do the assignment without it but it would require a much more careful methodology). The execution time of check_pass() depends on how many characters you guess correctly . Look in timehack.c and find a macro there for a function called rdtsc() which invokes the processors cycle counter (a clock that increments by one for each processor cycle that passes). In general, treat rdtsc() as a free running timer that returns a long . Insert a call to rdtsc() before the call to check_pass() and afterwards. Print the difference between these values to see how long (in cycles) the password checking ran. Run the program a few times. Now change the guess string so the first character is correct. Run again and see how the time difference changes. Now automate this entire process, in the style of the original approach in memhack.c . Note that unlike the memhack attack, the timehack problem will have to deal with noise . Depending on things like what other programs are running, the status of the cache, the contents of the branch target buffer, etc... there can be significant variability in the amount of time each check takes. This will matter in practice. You will want to run a lot of trials before you reach your conclusion about each character. Other hints: Be careful in using printf \u2019s. These can blow out the instruction cache and data caches and perturb your results (i.e. overwhelm the timing effects you are trying to detect). Be careful in averaging across trials. If your process is descheduled in the middle of a measurement, the time cost of that individual trial will be so large that it overwhelms everything else. Instead, the median is your friend. However, feel free to experiment if something does not work for you. If time is not continuing to increase as you progress through characters, then you probably made a bad guess earlier. Backtrack. rdtsc() will wrap around at some point. You may need to handle this outlier if it is causing issues. Debugging advice: make a big array to hold your timing measurements and print them at the end. Be sure to test a bunch of different passwords. We will when we grade.","title":"Timing-Based Side Channel"},{"location":"pa/pa3/#final-notes","text":"Do not write a solution that simply checks all passwords exhaustively. You will not get credit for this. This should be doable in linear time (we will stop programs that are running for excessive periods) and it will basically feel instantaneous for passwords of 8 characters or less (note we will not test passwords over 12 characters). We plan to do the testing/evaluation on our server.","title":"Final Notes"},{"location":"pa/pa4/","text":"Assignment 4 80pts \u00b6 Deadline: Friday, March 22, 2019 by 11:59:59 PM Early Turn-In: Monday, March 18, 2019 by 11:59:59 PM (15% bonus) Overview \u00b6 The goal of this assignment is to gain hands-on experience exploiting vulnerabilities on websites. This assignment will demonstrate how simple vulnerabilities (often occurring due to the carelessness of the website developer) can be really harmful to the website's owners. Security attacks include but aren't limited to stealing sensitive information, injecting malicious code, and causing the host server to crash. In this assignment, you have 8 'levels' or 'challenges' (each worth 10 points). In each challenge, you have to find the 'flag'. A flag is just a secret password that you need to find by exploiting certain vulnerabilities. Once you have the password, just enter it in the text box and hit the submit button to move up one level. Every challenge comes with hints and clues (present as text on the web page itself) which will guide you through exploiting a particular vulnerability. You may consult any online references you wish. Getting Started/Logging In \u00b6 Visit https://cse230-pa4.spinda.net . In this page, you will be asked to enter your PID and a password. You can find your password in your GradeScope account for this class (look for the \"PA4 Login Information\" assignment). A Word of Caution \u00b6 Each level comes with a description of its password. As mentioned before, every password is completely randomized for every level, and the fastest way to get to the password is by exploiting the said vulnerability. It should also be noted that brute-force techniques will not work. We have kept limits on the number of ping and http connections that every account can send to our server each day. If you reach this limit, you will be blocked for the rest of the day. So please do not try to DDOS the server with random tries. Prior Knowledge \u00b6 During the assignment, you may encounter situations that may require to either execute HTML, Client-side JavaScript or SQL statements. Some levels can be solved with a few lines written in Python. However, no code that you are expected to write in this assignment exceeds 10 (very small) lines. Most of the expected code is pretty generic and can be found with a quick Google search. The aim of the assignment is not to teach you coding in the said languages, but you give a hands-on experience with the tricks that most \"hackers\" or exploiters use in today's world. During no time are you expected to know \"truly fancy\" stuff like server-side PHP, ASP, JavaScript, AJAX, JQuery, Flash, CSS or in general - anything beyond the realms of the aforementioned techniques. Useful Resources \u00b6 Here are few resources which I think you will find very helpful while solving the assignment. They are, in no particular order: GET and POST requests - https://www.w3schools.com/tags/ref_httpmethods.asp Python Requests library - http://docs.python-requests.org/en/master/ Handling Cookies on your browser - https://kb.iu.edu/d/ajfi Intro to JavaScript - https://www.w3schools.com/js/default.asp Intro to SQL - https://www.w3schools.com/sql/sql_intro.asp Base64 Library (Python) Encoding and Decoding - https://code.tutsplus.com/tutorials/base64-encoding-and-decoding-using-python--cms-25588 Final Notes \u00b6 Exploiting vulnerabilities on web services is perhaps as old as the web. This assignment is designed to give you a first-hand feel of where people who exploit vulnerabilities look at. It is intended to make you think about these vulnerabilities, whenever you design a web service of your own. However, since it is intended for academic purposes, it is heavily toned down. Think of it as a toy model of the real world. We have even included hints and descriptions on every level. Just following these and only these should be enough to get you through. In the real world, the \"hacker\" will not have any hints and will have to systematically try everything. This is often long and meticulous, and not suited for assignment format. Hence, your best friends are the hints present in every level. Happy hacking!","title":"Assignment 4"},{"location":"pa/pa4/#assignment-4-80pts","text":"Deadline: Friday, March 22, 2019 by 11:59:59 PM Early Turn-In: Monday, March 18, 2019 by 11:59:59 PM (15% bonus)","title":"Assignment 4 80pts"},{"location":"pa/pa4/#overview","text":"The goal of this assignment is to gain hands-on experience exploiting vulnerabilities on websites. This assignment will demonstrate how simple vulnerabilities (often occurring due to the carelessness of the website developer) can be really harmful to the website's owners. Security attacks include but aren't limited to stealing sensitive information, injecting malicious code, and causing the host server to crash. In this assignment, you have 8 'levels' or 'challenges' (each worth 10 points). In each challenge, you have to find the 'flag'. A flag is just a secret password that you need to find by exploiting certain vulnerabilities. Once you have the password, just enter it in the text box and hit the submit button to move up one level. Every challenge comes with hints and clues (present as text on the web page itself) which will guide you through exploiting a particular vulnerability. You may consult any online references you wish.","title":"Overview"},{"location":"pa/pa4/#getting-startedlogging-in","text":"Visit https://cse230-pa4.spinda.net . In this page, you will be asked to enter your PID and a password. You can find your password in your GradeScope account for this class (look for the \"PA4 Login Information\" assignment).","title":"Getting Started/Logging In"},{"location":"pa/pa4/#a-word-of-caution","text":"Each level comes with a description of its password. As mentioned before, every password is completely randomized for every level, and the fastest way to get to the password is by exploiting the said vulnerability. It should also be noted that brute-force techniques will not work. We have kept limits on the number of ping and http connections that every account can send to our server each day. If you reach this limit, you will be blocked for the rest of the day. So please do not try to DDOS the server with random tries.","title":"A Word of Caution"},{"location":"pa/pa4/#prior-knowledge","text":"During the assignment, you may encounter situations that may require to either execute HTML, Client-side JavaScript or SQL statements. Some levels can be solved with a few lines written in Python. However, no code that you are expected to write in this assignment exceeds 10 (very small) lines. Most of the expected code is pretty generic and can be found with a quick Google search. The aim of the assignment is not to teach you coding in the said languages, but you give a hands-on experience with the tricks that most \"hackers\" or exploiters use in today's world. During no time are you expected to know \"truly fancy\" stuff like server-side PHP, ASP, JavaScript, AJAX, JQuery, Flash, CSS or in general - anything beyond the realms of the aforementioned techniques.","title":"Prior Knowledge"},{"location":"pa/pa4/#useful-resources","text":"Here are few resources which I think you will find very helpful while solving the assignment. They are, in no particular order: GET and POST requests - https://www.w3schools.com/tags/ref_httpmethods.asp Python Requests library - http://docs.python-requests.org/en/master/ Handling Cookies on your browser - https://kb.iu.edu/d/ajfi Intro to JavaScript - https://www.w3schools.com/js/default.asp Intro to SQL - https://www.w3schools.com/sql/sql_intro.asp Base64 Library (Python) Encoding and Decoding - https://code.tutsplus.com/tutorials/base64-encoding-and-decoding-using-python--cms-25588","title":"Useful Resources"},{"location":"pa/pa4/#final-notes","text":"Exploiting vulnerabilities on web services is perhaps as old as the web. This assignment is designed to give you a first-hand feel of where people who exploit vulnerabilities look at. It is intended to make you think about these vulnerabilities, whenever you design a web service of your own. However, since it is intended for academic purposes, it is heavily toned down. Think of it as a toy model of the real world. We have even included hints and descriptions on every level. Just following these and only these should be enough to get you through. In the real world, the \"hacker\" will not have any hints and will have to systematically try everything. This is often long and meticulous, and not suited for assignment format. Hence, your best friends are the hints present in every level. Happy hacking!","title":"Final Notes"}]}